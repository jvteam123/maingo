import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:geolocator/geolocator.dart';
import 'dart:async';
import 'dart:convert';
import 'package:http/http.dart' as http;
import 'package:google_maps_flutter/google_maps_flutter.dart' as gmaps;
// Firebase Imports
import 'package:firebase_core/firebase_core.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:font_awesome_flutter/font_awesome_flutter.dart';
import 'package:google_sign_in/google_sign_in.dart';
import 'firebase_options.dart';
import 'location_search_screen.dart';
import 'package:shared_preferences/shared_preferences.dart';
// Provider for State Management
import 'package:provider/provider.dart';

import 'package:flutter/foundation.dart'; // Required for kDebugMode
import 'package:firebase_app_check/firebase_app_check.dart';
// Generated by `flutterfire configure`

Future<void> main() async {
  // Ensure Flutter engine is ready
  WidgetsFlutterBinding.ensureInitialized();

  // Initialize Firebase
  await Firebase.initializeApp(
    options: DefaultFirebaseOptions.currentPlatform,
  );
  final promoRef =
      FirebaseFirestore.instance.collection('promos').doc('FOOD50');
  final promoDoc = await promoRef.get();
  if (!promoDoc.exists) {
    await promoRef.set({
      'code': 'FOOD50',
      'title': '₱50 OFF Food Delivery',
      'description':
          'Enjoy ₱50 off the delivery fee for any Food Delivery order from a partner store.',
      'applicableService': 'food',
    });
  }
  // Determine the App Check provider based on the platform
  // In a real-world app, you might use a debug provider for development
  final appCheckProvider = kDebugMode
      ? AndroidProvider.debug // Use debug provider for emulators/debug builds
      : AndroidProvider.playIntegrity; // Use Play Integrity for release builds

  // Activate Firebase App Check
  // This must be done before using other Firebase services
  await FirebaseAppCheck.instance.activate(
    androidProvider: appCheckProvider,
    // For iOS, you would use:
    // appleProvider: AppleProvider.appAttest,
  );

  print("Firebase App Check Activated with provider: ${appCheckProvider.name}");

  runApp(
    MultiProvider(
      providers: [
        ChangeNotifierProvider(create: (context) => PromoProvider()),
        ChangeNotifierProvider(create: (context) => CartProvider()),
      ],
      child: const GoHatodApp(),
    ),
  );
}

// --- DATA MODELS, ENUMS, & PROVIDERS ---
class MenuItem {
  final String name;
  final String description;
  final double price;
  final String imageUrl;
  MenuItem(
      {required this.name,
      required this.description,
      required this.price,
      required this.imageUrl});
}

class Store {
  final String id;
  final String name;
  final String cuisine;
  final String imageUrl;
  final double rating;
  final String deliveryTime;
  final gmaps.LatLng coordinates;
  final List<MenuItem> menu;
  Store({
    required this.id,
    required this.name,
    required this.cuisine,
    required this.imageUrl,
    required this.rating,
    required this.deliveryTime,
    required this.coordinates,
    required this.menu,
  });
  factory Store.fromFirestore(DocumentSnapshot doc) {
    Map<String, dynamic> data = doc.data() as Map<String, dynamic>;
    GeoPoint coordinates = data['coordinates'] ?? const GeoPoint(0, 0);
    return Store(
        id: doc.id,
        name: data['name'] ?? 'No Name',
        cuisine: data['cuisine'] ?? 'N/A',
        imageUrl: data['imageUrl'] ?? 'https://via.placeholder.com/400x140.png',
        rating: (data['rating'] ?? 0.0).toDouble(),
        deliveryTime: data['deliveryTime'] ?? 'N/A',
        coordinates: gmaps.LatLng(coordinates.latitude, coordinates.longitude),
        menu: [
          MenuItem(
              name: 'Special Lechon',
              description: '1/4 kg of classic spicy lechon.',
              price: 240.00,
              imageUrl: ''),
          MenuItem(
              name: 'Lechon Sisig',
              description: 'Sizzling chopped lechon with onions.',
              price: 280.00,
              imageUrl: '')
        ]);
  }
}

enum ServiceType { ride, pabili, food }

class Promo {
  final String code;
  final String title;
  final String description;
  final ServiceType applicableService;

  const Promo({
    required this.code,
    required this.title,
    required this.description,
    required this.applicableService,
  });
}

class PromoProvider with ChangeNotifier {
  Promo? _activePromo;
  Promo? get activePromo => _activePromo;
  void setActivePromo(Promo? promo) {
    _activePromo = promo;
    notifyListeners();
  }
}

class CartItem {
  final MenuItem menuItem;
  int quantity;
  CartItem({required this.menuItem, this.quantity = 1});
}

class CartProvider with ChangeNotifier {
  final Map<String, CartItem> _items = {};
  Map<String, CartItem> get items => {..._items};
  int get itemCount {
    return _items.values.fold(0, (sum, item) => sum + item.quantity);
  }

  double get totalPrice {
    var total = 0.0;
    _items.forEach((key, cartItem) {
      total += cartItem.menuItem.price * cartItem.quantity;
    });
    return total;
  }

  void addToCart(MenuItem menuItem) {
    if (_items.containsKey(menuItem.name)) {
      _items.update(
          menuItem.name,
          (existing) => CartItem(
              menuItem: existing.menuItem, quantity: existing.quantity + 1));
    } else {
      _items.putIfAbsent(menuItem.name, () => CartItem(menuItem: menuItem));
    }
    notifyListeners();
  }

  void clearCart() {
    _items.clear();
    notifyListeners();
  }
}

final List<Promo> mockPromos = [
  const Promo(
    code: 'RIDE20',
    title: '20% OFF Your Next Ride!',
    description:
        'Get 20% off on any single motorcycle ride. Max discount PHP 40.',
    applicableService: ServiceType.ride,
  ),
  const Promo(
    code: 'PABILIFREE',
    title: 'Free Delivery on Pabili',
    description:
        'Get your items delivered for free! Applies to the delivery fee.',
    applicableService: ServiceType.pabili,
  ),
  const Promo(
    code: 'FOOD50',
    title: 'PHP 50 Off Food Delivery',
    description:
        'Enjoy PHP 50 off the delivery fee for any Food Delivery order from a partner store.',
    applicableService: ServiceType.food,
  ),
];
MaterialColor _createMaterialColor(Color color) {
  List strengths = <double>[.05];
  Map<int, Color> swatch = {};
  final int r = color.red, g = color.green, b = color.blue;
  for (int i = 1; i < 10; i++) {
    strengths.add(0.1 * i);
  }
  strengths.forEach((strength) {
    final double ds = 0.5 - strength;
    swatch[(strength * 1000).round()] = Color.fromRGBO(
      r + ((ds < 0 ? r : (255 - r)) * ds).round(),
      g + ((ds < 0 ? g : (255 - g)) * ds).round(),
      b + ((ds < 0 ? b : (255 - b)) * ds).round(),
      1,
    );
  });
  return MaterialColor(color.value, swatch);
}

// --- APP & AUTHENTICATION WIDGETS ---
class GoHatodApp extends StatelessWidget {
  const GoHatodApp({super.key});
  @override
  Widget build(BuildContext context) {
    const Color primaryColor = Color(0xFFE52D7A);
    const Color accentColor = Color(0xFFFFA000);

    return MaterialApp(
      title: 'GoHatod',
      debugShowCheckedModeBanner: false,
      theme: ThemeData(
        primarySwatch: _createMaterialColor(primaryColor),
        primaryColor: primaryColor,
        colorScheme: ColorScheme.fromSeed(
            seedColor: primaryColor, secondary: accentColor),
        scaffoldBackgroundColor: const Color(0xFFF7F9FC),
        appBarTheme: AppBarTheme(
          backgroundColor: primaryColor,
          foregroundColor: Colors.white,
          elevation: 2.0,
          titleTextStyle: const TextStyle(
              fontFamily: 'Roboto',
              color: Colors.white,
              fontSize: 20,
              fontWeight: FontWeight.bold),
          iconTheme: const IconThemeData(color: Colors.white),
        ),
        elevatedButtonTheme: ElevatedButtonThemeData(
          style: ElevatedButton.styleFrom(
            backgroundColor: primaryColor,
            foregroundColor: Colors.white,
            padding: const EdgeInsets.symmetric(vertical: 12, horizontal: 24),
            textStyle: const TextStyle(
                fontFamily: 'Roboto',
                fontSize: 16,
                fontWeight: FontWeight.bold),
            shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(25.0)),
            elevation: 2.0,
          ),
        ),
        inputDecorationTheme: InputDecorationTheme(
          filled: true,
          fillColor: const Color(0xFFFFFFFF),
          hintStyle: TextStyle(color: Colors.grey[500]),
          labelStyle: const TextStyle(color: primaryColor),
          border: OutlineInputBorder(
              borderRadius: BorderRadius.circular(12.0),
              borderSide: BorderSide(color: Colors.grey[300]!)),
          enabledBorder: OutlineInputBorder(
              borderRadius: BorderRadius.circular(12.0),
              borderSide: BorderSide(color: Colors.grey[300]!)),
          focusedBorder: OutlineInputBorder(
              borderRadius: BorderRadius.circular(12.0),
              borderSide: BorderSide(color: accentColor, width: 2.0)),
        ),
        cardTheme: CardThemeData(
          elevation: 2.0,
          shape:
              RoundedRectangleBorder(borderRadius: BorderRadius.circular(12.0)),
          margin: const EdgeInsets.symmetric(vertical: 6.0, horizontal: 4.0),
        ),
      ),
      home: const AuthWrapper(),
    );
  }
}

class AuthWrapper extends StatelessWidget {
  const AuthWrapper({super.key});
  @override
  Widget build(BuildContext context) {
    return StreamBuilder<User?>(
      stream: FirebaseAuth.instance.authStateChanges(),
      builder: (context, snapshot) {
        if (snapshot.connectionState == ConnectionState.waiting) {
          return const Scaffold(
              body: Center(child: CircularProgressIndicator()));
        }
        if (snapshot.hasData) {
          // Check for active booking
          return FutureBuilder<QuerySnapshot>(
            future: FirebaseFirestore.instance
                .collection('bookings')
                .where('userId', isEqualTo: snapshot.data!.uid)
                .where('status', isEqualTo: 'active')
                .limit(1)
                .get(),
            builder: (context, bookingSnap) {
              if (!bookingSnap.hasData)
                return const Scaffold(
                    body: Center(child: CircularProgressIndicator()));
              if (bookingSnap.data!.docs.isNotEmpty) {
                final bookingId = bookingSnap.data!.docs.first.id;
                return ActiveBookingScreen(bookingId: bookingId);
              }
              return const MainAppShell();
            },
          );
        }
        return LoginScreen();
      },
    );
  }
}

// ... (keep all code above unchanged) ...

// --- ALL APP SCREENS AND WIDGETS ---
class LoginScreen extends StatefulWidget {
  const LoginScreen({super.key});
  @override
  _LoginScreenState createState() => _LoginScreenState();
}

class _LoginScreenState extends State<LoginScreen> {
  final TextEditingController _phoneController = TextEditingController();
  final TextEditingController _otpController = TextEditingController();
  final GlobalKey<FormState> _formKey = GlobalKey<FormState>();
  String? _verificationId;
  bool _isOtpSent = false;
  bool _isLoading = false;

  Future<void> _signInWithGoogle() async {
    setState(() {
      _isLoading = true;
    });
    try {
      final GoogleSignInAccount? googleUser = await GoogleSignIn().signIn();
      if (googleUser == null) {
        if (mounted) setState(() => _isLoading = false);
        return;
      }
      final GoogleSignInAuthentication googleAuth =
          await googleUser.authentication;
      final AuthCredential credential = GoogleAuthProvider.credential(
        accessToken: googleAuth.accessToken,
        idToken: googleAuth.idToken,
      );
      await FirebaseAuth.instance.signInWithCredential(credential);
    } catch (e) {
      if (mounted) {
        setState(() => _isLoading = false);
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
              content: Text("Google Sign-In Failed: $e"),
              backgroundColor: Colors.red),
        );
      }
    }
  }

  Future<void> _sendOtp() async {
    if (!_formKey.currentState!.validate()) return;
    setState(() {
      _isLoading = true;
    });
    String phoneNumber = "+63${_phoneController.text.trim()}";

    await FirebaseAuth.instance.verifyPhoneNumber(
      phoneNumber: phoneNumber,
      verificationCompleted: (PhoneAuthCredential credential) async {
        if (!mounted) return;
        setState(() {
          _isLoading = false;
        });
        await FirebaseAuth.instance.signInWithCredential(credential);
      },
      verificationFailed: (FirebaseAuthException e) {
        if (!mounted) return;
        setState(() {
          _isLoading = false;
        });
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
              content: Text("Failed to send OTP: ${e.message}"),
              backgroundColor: Colors.red),
        );
      },
      codeSent: (String verificationId, int? resendToken) {
        if (!mounted) return;
        setState(() {
          _verificationId = verificationId;
          _isOtpSent = true;
          _isLoading = false;
        });
      },
      codeAutoRetrievalTimeout: (String verificationId) {
        if (!mounted) return;
        setState(() {
          _verificationId = verificationId;
        });
      },
      timeout: const Duration(seconds: 60),
    );
  }

  Future<void> _verifyOtp() async {
    if (_verificationId == null) {
      ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text("Verification ID not found.")));
      return;
    }
    setState(() {
      _isLoading = true;
    });
    try {
      PhoneAuthCredential credential = PhoneAuthProvider.credential(
        verificationId: _verificationId!,
        smsCode: _otpController.text.trim(),
      );
      await FirebaseAuth.instance.signInWithCredential(credential);
    } on FirebaseAuthException catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
            content: Text("Sign in failed: ${e.message}"),
            backgroundColor: Colors.red),
      );
    } finally {
      if (mounted) {
        setState(() {
          _isLoading = false;
        });
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Login to GoHatod')),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(24.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            const SizedBox(height: 20),
            Icon(Icons.two_wheeler,
                size: 80, color: Theme.of(context).primaryColor),
            const SizedBox(height: 20),
            OutlinedButton.icon(
              icon: FaIcon(FontAwesomeIcons.google, color: Colors.red),
              label: const Text('Sign in with Google',
                  style: TextStyle(
                      color: Colors.black54, fontWeight: FontWeight.w600)),
              onPressed: _isLoading ? null : _signInWithGoogle,
              style: OutlinedButton.styleFrom(
                backgroundColor: Colors.white,
                side: BorderSide(color: Colors.grey[300]!),
                shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(8.0)),
                padding: const EdgeInsets.symmetric(vertical: 12),
              ),
            ),
            const Padding(
              padding: EdgeInsets.symmetric(vertical: 16.0),
              child: Row(
                children: [
                  Expanded(child: Divider()),
                  Padding(
                      padding: EdgeInsets.symmetric(horizontal: 8.0),
                      child: Text('OR', style: TextStyle(color: Colors.grey))),
                  Expanded(child: Divider()),
                ],
              ),
            ),
            Form(
              key: _formKey,
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.stretch,
                children: [
                  Text('Sign in with your mobile number',
                      textAlign: TextAlign.center,
                      style: Theme.of(context).textTheme.titleMedium),
                  const SizedBox(height: 20),
                  TextFormField(
                    controller: _phoneController,
                    enabled: !_isOtpSent,
                    decoration: const InputDecoration(
                        prefixText: "+63 ",
                        labelText: "Mobile Number",
                        hintText: "9171234567"),
                    keyboardType: TextInputType.phone,
                    inputFormatters: [
                      FilteringTextInputFormatter.digitsOnly,
                      LengthLimitingTextInputFormatter(10)
                    ],
                    validator: (value) {
                      if (value == null || value.length < 10) {
                        return 'Please enter a valid 10-digit number.';
                      }
                      return null;
                    },
                  ),
                  const SizedBox(height: 20),
                  Visibility(
                    visible: _isOtpSent,
                    maintainState: true,
                    maintainAnimation: true,
                    maintainSize: true,
                    child: TextFormField(
                      controller: _otpController,
                      autofocus: _isOtpSent,
                      decoration: const InputDecoration(
                          labelText: "OTP Code",
                          hintText: "Enter 6-digit code",
                          counterText: ""),
                      keyboardType: TextInputType.number,
                      textAlign: TextAlign.center,
                      maxLength: 6,
                    ),
                  ),
                  const SizedBox(height: 20),
                  if (_isLoading)
                    const Center(child: CircularProgressIndicator())
                  else
                    ElevatedButton(
                      onPressed: _isOtpSent ? _verifyOtp : _sendOtp,
                      child: Text(_isOtpSent ? 'VERIFY & LOGIN' : 'SEND OTP'),
                    ),
                  if (_isOtpSent && !_isLoading)
                    TextButton(
                      onPressed: () {
                        setState(() {
                          _isOtpSent = false;
                          _verificationId = null;
                          _otpController.clear();
                        });
                      },
                      child: const Text("Change or Resend?"),
                    ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }
}

// --- MAIN APP STRUCTURE ---
class MainAppShell extends StatefulWidget {
  const MainAppShell({super.key});
  @override
  State<MainAppShell> createState() => _MainAppShellState();
}

class _MainAppShellState extends State<MainAppShell> {
  int _selectedIndex = 0;

  Future<int> _getLastSeenPromoTimestamp() async {
    final prefs = await SharedPreferences.getInstance();
    return prefs.getInt('lastSeenPromo') ?? 0;
  }

  Future<void> _setLastSeenPromoTimestamp(int timestamp) async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setInt('lastSeenPromo', timestamp);
  }

  Future<int> _getLastSeenSupportTimestamp() async {
    final prefs = await SharedPreferences.getInstance();
    return prefs.getInt('lastSeenSupport') ?? 0;
  }

  Future<void> _setLastSeenSupportTimestamp(int timestamp) async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setInt('lastSeenSupport', timestamp);
  }

  void _onItemTapped(int index) {
    setState(() {
      _selectedIndex = index;
    });
  }

  @override
  Widget build(BuildContext context) {
    final user = FirebaseAuth.instance.currentUser;

    // List of screens for each tab
    final List<Widget> _pages = [
      const CustomerServiceSelectionScreen(),
      const ActivityScreen(),
      const PromoScreen(),
      const SupportScreen(),
    ];

    return FutureBuilder<int>(
      future: _getLastSeenPromoTimestamp(),
      builder: (context, lastSeenPromoSnap) {
        final lastSeenPromo = lastSeenPromoSnap.data ?? 0;
        return StreamBuilder<QuerySnapshot>(
          stream: FirebaseFirestore.instance
              .collection('promos')
              .orderBy('createdAt', descending: true)
              .limit(1)
              .snapshots(),
          builder: (context, promoSnap) {
            int newPromoBadge = 0;
            int latestPromoTimestamp = 0;
            if (promoSnap.hasData && promoSnap.data!.docs.isNotEmpty) {
              final promo = promoSnap.data!.docs.first;
              latestPromoTimestamp =
                  (promo['createdAt'] as Timestamp?)?.millisecondsSinceEpoch ??
                      0;
              if (latestPromoTimestamp > lastSeenPromo) {
                newPromoBadge = 1;
              }
            }

            return FutureBuilder<int>(
              future: _getLastSeenSupportTimestamp(),
              builder: (context, lastSeenSupportSnap) {
                final lastSeenSupport = lastSeenSupportSnap.data ?? 0;
                return StreamBuilder<QuerySnapshot>(
                  stream: user == null
                      ? null
                      : FirebaseFirestore.instance
                          .collection('supportChats')
                          .doc('${user.uid}_other')
                          .collection('messages')
                          .orderBy('timestamp', descending: true)
                          .limit(1)
                          .snapshots(),
                  builder: (context, supportSnap) {
                    int newSupportBadge = 0;
                    int latestSupportTimestamp = 0;
                    if (supportSnap.hasData &&
                        supportSnap.data!.docs.isNotEmpty) {
                      final msg = supportSnap.data!.docs.first.data()
                          as Map<String, dynamic>;
                      latestSupportTimestamp = (msg['timestamp'] as Timestamp?)
                              ?.millisecondsSinceEpoch ??
                          0;
                      if (msg['senderId'] != user?.uid &&
                          latestSupportTimestamp > lastSeenSupport) {
                        newSupportBadge = 1;
                      }
                    }

                    return StreamBuilder<QuerySnapshot>(
                      stream: FirebaseFirestore.instance
                          .collection('bookings')
                          .where('userId', isEqualTo: user?.uid)
                          .where('status', isEqualTo: 'active')
                          .snapshots(),
                      builder: (context, snapshot) {
                        int activeCount = 0;
                        if (snapshot.hasData) {
                          activeCount = snapshot.data!.docs.length;
                        }
                        return Scaffold(
                          body: _pages[
                              _selectedIndex], // <-- THIS SHOWS THE CORRECT SCREEN
                          bottomNavigationBar: BottomNavigationBar(
                            currentIndex: _selectedIndex,
                            onTap: (index) async {
                              _onItemTapped(index);
                              if (index == 2 && latestPromoTimestamp > 0) {
                                await _setLastSeenPromoTimestamp(
                                    latestPromoTimestamp);
                              }
                              if (index == 3 && latestSupportTimestamp > 0) {
                                await _setLastSeenSupportTimestamp(
                                    latestSupportTimestamp);
                              }
                            },
                            type: BottomNavigationBarType.fixed,
                            selectedItemColor: Theme.of(context).primaryColor,
                            unselectedItemColor: Colors.grey[600],
                            items: <BottomNavigationBarItem>[
                              const BottomNavigationBarItem(
                                  icon: Icon(Icons.home_outlined),
                                  activeIcon: Icon(Icons.home),
                                  label: 'Home'),
                              BottomNavigationBarItem(
                                icon: Stack(
                                  clipBehavior: Clip.none,
                                  children: [
                                    const Icon(Icons.receipt_long_outlined),
                                    if (activeCount > 0)
                                      Positioned(
                                        right: -6,
                                        top: -4,
                                        child: Container(
                                          padding: const EdgeInsets.all(2),
                                          decoration: BoxDecoration(
                                            color: Colors.red,
                                            borderRadius:
                                                BorderRadius.circular(10),
                                          ),
                                          constraints: const BoxConstraints(
                                            minWidth: 16,
                                            minHeight: 16,
                                          ),
                                          child: Text(
                                            '$activeCount',
                                            style: const TextStyle(
                                              color: Colors.white,
                                              fontSize: 10,
                                              fontWeight: FontWeight.bold,
                                            ),
                                            textAlign: TextAlign.center,
                                          ),
                                        ),
                                      ),
                                  ],
                                ),
                                activeIcon: Stack(
                                  clipBehavior: Clip.none,
                                  children: [
                                    const Icon(Icons.receipt_long),
                                    if (activeCount > 0)
                                      Positioned(
                                        right: -6,
                                        top: -4,
                                        child: Container(
                                          padding: const EdgeInsets.all(2),
                                          decoration: BoxDecoration(
                                            color: Colors.red,
                                            borderRadius:
                                                BorderRadius.circular(10),
                                          ),
                                          constraints: const BoxConstraints(
                                            minWidth: 16,
                                            minHeight: 16,
                                          ),
                                          child: Text(
                                            '$activeCount',
                                            style: const TextStyle(
                                              color: Colors.white,
                                              fontSize: 10,
                                              fontWeight: FontWeight.bold,
                                            ),
                                            textAlign: TextAlign.center,
                                          ),
                                        ),
                                      ),
                                  ],
                                ),
                                label: 'Activity',
                              ),
                              BottomNavigationBarItem(
                                icon: Stack(
                                  clipBehavior: Clip.none,
                                  children: [
                                    const Icon(Icons.local_offer_outlined),
                                    if (newPromoBadge > 0)
                                      Positioned(
                                        right: -6,
                                        top: -4,
                                        child: Container(
                                          width: 12,
                                          height: 12,
                                          decoration: BoxDecoration(
                                            color: Colors.red,
                                            borderRadius:
                                                BorderRadius.circular(8),
                                          ),
                                        ),
                                      ),
                                  ],
                                ),
                                activeIcon: Stack(
                                  clipBehavior: Clip.none,
                                  children: [
                                    const Icon(Icons.local_offer),
                                    if (newPromoBadge > 0)
                                      Positioned(
                                        right: -6,
                                        top: -4,
                                        child: Container(
                                          width: 12,
                                          height: 12,
                                          decoration: BoxDecoration(
                                            color: Colors.red,
                                            borderRadius:
                                                BorderRadius.circular(8),
                                          ),
                                        ),
                                      ),
                                  ],
                                ),
                                label: 'Promo',
                              ),
                              BottomNavigationBarItem(
                                icon: Stack(
                                  clipBehavior: Clip.none,
                                  children: [
                                    const Icon(Icons.support_agent_outlined),
                                    if (newSupportBadge > 0)
                                      Positioned(
                                        right: -6,
                                        top: -4,
                                        child: Container(
                                          width: 12,
                                          height: 12,
                                          decoration: BoxDecoration(
                                            color: Colors.red,
                                            borderRadius:
                                                BorderRadius.circular(8),
                                          ),
                                        ),
                                      ),
                                  ],
                                ),
                                activeIcon: Stack(
                                  clipBehavior: Clip.none,
                                  children: [
                                    const Icon(Icons.support_agent),
                                    if (newSupportBadge > 0)
                                      Positioned(
                                        right: -6,
                                        top: -4,
                                        child: Container(
                                          width: 12,
                                          height: 12,
                                          decoration: BoxDecoration(
                                            color: Colors.red,
                                            borderRadius:
                                                BorderRadius.circular(8),
                                          ),
                                        ),
                                      ),
                                  ],
                                ),
                                label: 'Support',
                              ),
                            ],
                          ),
                        );
                      },
                    );
                  },
                );
              },
            );
          },
        );
      },
    );
  }
}

// --- ALL APP SCREENS AND WIDGETS ---

class CustomerServiceSelectionScreen extends StatelessWidget {
  const CustomerServiceSelectionScreen({Key? key}) : super(key: key);

  void _navigateToRequestPage(BuildContext context, ServiceType service) {
    Navigator.push(context, MaterialPageRoute(builder: (context) {
      return RequestServicePage(initialServiceType: service);
    }));
  }

  void _navigateToStoreListing(BuildContext context) {
    Navigator.push(context, MaterialPageRoute(builder: (context) {
      return const StoreListingScreen();
    }));
  }

  void _navigateToProfile(BuildContext context) {
    Navigator.push(context, MaterialPageRoute(builder: (context) {
      return const UserProfileScreen();
    }));
  }

  @override
  Widget build(BuildContext context) {
    final user = FirebaseAuth.instance.currentUser;
    return Scaffold(
      appBar: AppBar(
        title: const Text('GoHatod'),
        centerTitle: true,
        actions: [
          Padding(
            padding: const EdgeInsets.only(right: 16.0),
            child: GestureDetector(
              onTap: () => _navigateToProfile(context),
              child: CircleAvatar(
                backgroundColor: Colors.white,
                radius: 18,
                child: Icon(
                  Icons.person,
                  color: Theme.of(context).primaryColor,
                  size: 24,
                ),
              ),
            ),
          ),
        ],
      ),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(20.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: <Widget>[
            const SizedBox(height: 10),
            Text('Hi there,',
                style: Theme.of(context)
                    .textTheme
                    .titleLarge
                    ?.copyWith(fontWeight: FontWeight.normal)),
            Text(user?.phoneNumber ?? 'Guest User',
                style: Theme.of(context).textTheme.headlineSmall),
            const SizedBox(height: 30),
            Text('What can we get for you today?',
                style: Theme.of(context)
                    .textTheme
                    .titleLarge
                    ?.copyWith(fontWeight: FontWeight.bold)),
            const SizedBox(height: 20),
            ServiceCard(
              icon: Icons.storefront_outlined,
              title: 'Food Delivery',
              subtitle: 'Browse stores and menus',
              onTap: () => _navigateToStoreListing(context),
            ),
            const SizedBox(height: 16),
            ServiceCard(
              icon: Icons.two_wheeler_outlined,
              title: 'Book a Ride',
              subtitle: 'Get a ride to your destination',
              onTap: () => _navigateToRequestPage(context, ServiceType.ride),
            ),
            const SizedBox(height: 16),
            ServiceCard(
              icon: Icons.shopping_bag_outlined,
              title: 'Pabili',
              subtitle: 'Request a rider to buy items',
              onTap: () => _navigateToRequestPage(context, ServiceType.pabili),
            ),
          ],
        ),
      ),
    );
  }
}

// --- USER PROFILE SCREEN ---
class UserProfileScreen extends StatelessWidget {
  const UserProfileScreen({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final user = FirebaseAuth.instance.currentUser;
    return Scaffold(
      appBar: AppBar(
        title: const Text('Profile'),
      ),
      body: Padding(
        padding: const EdgeInsets.all(24.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                CircleAvatar(
                  radius: 32,
                  backgroundColor: Colors.grey[300],
                  child: Icon(Icons.person, size: 40, color: Colors.grey[700]),
                ),
                const SizedBox(width: 20),
                Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      user?.displayName ?? 'User',
                      style: Theme.of(context).textTheme.titleLarge,
                    ),
                    Text(
                      user?.phoneNumber ?? user?.email ?? 'No contact info',
                      style: Theme.of(context).textTheme.bodyMedium,
                    ),
                  ],
                ),
              ],
            ),
            const SizedBox(height: 30),
            ListTile(
              leading: const Icon(Icons.logout, color: Colors.red),
              title: const Text('Sign Out'),
              onTap: () async {
                await FirebaseAuth.instance.signOut();
                Navigator.of(context).pop();
              },
            ),
          ],
        ),
      ),
    );
  }
}

// Helper widget for service cards

class ServiceCard extends StatelessWidget {
  final IconData icon;
  final String title;
  final String subtitle;
  final VoidCallback onTap;
  const ServiceCard({
    Key? key,
    required this.icon,
    required this.title,
    required this.subtitle,
    required this.onTap,
  }) : super(key: key);
  @override
  Widget build(BuildContext context) {
    return Card(
      child: InkWell(
        onTap: onTap,
        borderRadius: BorderRadius.circular(12.0),
        child: Padding(
          padding: const EdgeInsets.symmetric(vertical: 16.0, horizontal: 16.0),
          child: Row(
            children: <Widget>[
              Icon(icon, size: 40.0, color: Theme.of(context).primaryColor),
              const SizedBox(width: 16),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(title, style: Theme.of(context).textTheme.titleLarge),
                    const SizedBox(height: 4),
                    Text(
                      subtitle,
                      style: Theme.of(context).textTheme.bodyMedium,
                    ),
                  ],
                ),
              ),
              const Icon(Icons.arrow_forward_ios, size: 16, color: Colors.grey),
            ],
          ),
        ),
      ),
    );
  }
}

class ActivityScreen extends StatelessWidget {
  const ActivityScreen({super.key});
  @override
  Widget build(BuildContext context) {
    final user = FirebaseAuth.instance.currentUser;
    if (user == null) {
      return const Center(child: Text('Please log in to view your activity.'));
    }
    return StreamBuilder<QuerySnapshot>(
      stream: FirebaseFirestore.instance
          .collection('bookings')
          .where('userId', isEqualTo: user.uid)
          // Remove orderBy if you suspect missing createdAt fields, or handle missing fields below
          .orderBy('createdAt', descending: true)
          .snapshots(),
      builder: (context, snapshot) {
        if (snapshot.connectionState == ConnectionState.waiting) {
          return const Center(child: CircularProgressIndicator());
        }
        if (snapshot.hasError) {
          return Center(child: Text('Error: ${snapshot.error}'));
        }
        if (!snapshot.hasData || snapshot.data!.docs.isEmpty) {
          return const Center(child: Text('No bookings yet.'));
        }
        // Build a list of bookings
        return ListView.builder(
          itemCount: snapshot.data!.docs.length,
          itemBuilder: (context, index) {
            final doc = snapshot.data!.docs[index];
            final data = doc.data() as Map<String, dynamic>;
            final bookingId = doc.id;
            final serviceType = (data['serviceType'] ?? '').toString();
            final pickup = (data['pickup']?['address'] ?? '').toString();
            final destination =
                (data['destination']?['address'] ?? '').toString();
            final fare = (data['fare'] ?? '').toString();
            final status = (data['status'] ?? '').toString();
            final createdAtTimestamp = data['createdAt'];
            DateTime? createdAt;
            if (createdAtTimestamp is Timestamp) {
              createdAt = createdAtTimestamp.toDate();
            }
            final isActive = status == 'active';
            final isCompleted = status == 'completed';
            final isCancelled = status == 'cancelled';
            Color statusColor;
            if (isActive) {
              statusColor = Colors.green;
            } else if (isCompleted) {
              statusColor = Colors.blueGrey;
            } else if (isCancelled) {
              statusColor = Colors.red;
            } else {
              statusColor = Colors.grey;
            }

            return Card(
              margin: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
              child: Column(
                children: [
                  ListTile(
                    leading: Icon(
                      serviceType == 'ride'
                          ? Icons.two_wheeler
                          : serviceType == 'pabili'
                              ? Icons.shopping_bag
                              : Icons.storefront,
                      color: Theme.of(context).primaryColor,
                    ),
                    title: Text(
                      '${serviceType.isNotEmpty ? serviceType[0].toUpperCase() + serviceType.substring(1) : ''}',
                      style: const TextStyle(fontWeight: FontWeight.bold),
                    ),
                    subtitle: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        if (pickup.isNotEmpty) Text('From: $pickup'),
                        if (destination.isNotEmpty) Text('To: $destination'),
                        if (fare.isNotEmpty) Text('Fare: $fare'),
                        if (createdAt != null)
                          Text(
                            'Date: ${createdAt.toLocal()}'.split('.').first,
                            style: const TextStyle(
                                fontSize: 12, color: Colors.grey),
                          ),
                      ],
                    ),
                    trailing: Container(
                      padding: const EdgeInsets.symmetric(
                          horizontal: 10, vertical: 4),
                      decoration: BoxDecoration(
                        color: statusColor.withOpacity(0.15),
                        borderRadius: BorderRadius.circular(8),
                      ),
                      child: Text(
                        status,
                        style: TextStyle(
                          color: statusColor,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                    ),
                    onTap: isActive
                        ? () {
                            Navigator.push(
                              context,
                              MaterialPageRoute(
                                builder: (_) =>
                                    ActiveBookingScreen(bookingId: bookingId),
                              ),
                            );
                          }
                        : null,
                  ),
                  // Action buttons for completed/cancelled
                  if (isCompleted || isCancelled)
                    Padding(
                      padding: const EdgeInsets.only(
                          left: 16, right: 16, bottom: 10),
                      child: Row(
                        mainAxisAlignment: MainAxisAlignment.end,
                        children: [
                          if (isCompleted)
                            ElevatedButton.icon(
                              icon: const Icon(Icons.repeat),
                              label: const Text('Repeat Order'),
                              style: ElevatedButton.styleFrom(
                                backgroundColor: Theme.of(context).primaryColor,
                              ),
                              onPressed: () async {
                                // Fetch the booking data again to ensure up-to-date info
                                final doc = await FirebaseFirestore.instance
                                    .collection('bookings')
                                    .doc(bookingId)
                                    .get();
                                final repeatData =
                                    doc.data() as Map<String, dynamic>;
                                // Remove fields that should not be copied
                                repeatData.remove('status');
                                repeatData.remove('createdAt');
                                repeatData.remove('cancelledAt');
                                repeatData.remove('completedAt');
                                repeatData.remove('cancellationReason');
                                repeatData.remove('cancellationRequested');
                                repeatData.remove('cancellationStatus');
                                repeatData.remove('driver');
                                repeatData.remove('rider');
                                repeatData['status'] = 'active';
                                repeatData['createdAt'] =
                                    FieldValue.serverTimestamp();

                                await FirebaseFirestore.instance
                                    .collection('bookings')
                                    .add(repeatData);

                                ScaffoldMessenger.of(context).showSnackBar(
                                  const SnackBar(
                                      content: Text('Order repeated!')),
                                );
                              },
                            ),
                          const SizedBox(width: 8),
                          ElevatedButton.icon(
                            icon: const Icon(Icons.delete),
                            label: const Text('Delete'),
                            style: ElevatedButton.styleFrom(
                              backgroundColor: Colors.red,
                            ),
                            onPressed: () async {
                              await FirebaseFirestore.instance
                                  .collection('bookings')
                                  .doc(bookingId)
                                  .delete();
                              ScaffoldMessenger.of(context).showSnackBar(
                                const SnackBar(content: Text('Order deleted.')),
                              );
                            },
                          ),
                        ],
                      ),
                    ),
                ],
              ),
            );
          },
        );
      },
    );
  }
}

class PromoScreen extends StatelessWidget {
  const PromoScreen({super.key});
  @override
  Widget build(BuildContext context) {
    final promoProvider = Provider.of<PromoProvider>(context, listen: false);
    return StreamBuilder<QuerySnapshot>(
      stream: FirebaseFirestore.instance.collection('promos').snapshots(),
      builder: (context, snapshot) {
        if (snapshot.connectionState == ConnectionState.waiting) {
          return const Center(child: CircularProgressIndicator());
        }
        if (snapshot.hasError) {
          return Center(child: Text('Error: ${snapshot.error}'));
        }
        if (!snapshot.hasData || snapshot.data!.docs.isEmpty) {
          return const Center(child: Text('No promos available.'));
        }
        final promos = snapshot.data!.docs;
        return ListView.builder(
          padding: const EdgeInsets.fromLTRB(
              12.0, 32.0, 12.0, 12.0), // <-- Add top margin here
          itemCount: promos.length,
          itemBuilder: (context, index) {
            final data = promos[index].data() as Map<String, dynamic>;
            final promo = Promo(
              code: data['code'] ?? '',
              title: data['title'] ?? '',
              description: data['description'] ?? '',
              applicableService: ServiceType.values.firstWhere(
                (e) => e.name == (data['applicableService'] ?? 'ride'),
                orElse: () => ServiceType.ride,
              ),
            );
            return Card(
              elevation: 3.0,
              margin: const EdgeInsets.symmetric(vertical: 8.0),
              child: Padding(
                padding: const EdgeInsets.all(16.0),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      promo.title,
                      style: Theme.of(context).textTheme.titleLarge?.copyWith(
                            color: Theme.of(context).primaryColor,
                            fontWeight: FontWeight.bold,
                          ),
                    ),
                    const SizedBox(height: 8),
                    Text(promo.description,
                        style: Theme.of(context).textTheme.bodyMedium),
                    const SizedBox(height: 12),
                    Align(
                      alignment: Alignment.centerRight,
                      child: ElevatedButton(
                        onPressed: () {
                          promoProvider.setActivePromo(promo);

                          // Show feedback
                          ScaffoldMessenger.of(context).showSnackBar(
                            SnackBar(
                              content: Text("'${promo.code}' promo applied!"),
                              backgroundColor:
                                  Theme.of(context).colorScheme.secondary,
                            ),
                          );

                          // Navigate to the correct service page
                          if (promo.applicableService == ServiceType.food) {
                            Navigator.of(context).pushAndRemoveUntil(
                              MaterialPageRoute(
                                  builder: (_) => const MainAppShell()),
                              (route) => false,
                            );
                            // Open Food Delivery (StoreListingScreen)
                            Future.delayed(const Duration(milliseconds: 300),
                                () {
                              Navigator.of(context).push(
                                MaterialPageRoute(
                                    builder: (_) => const StoreListingScreen()),
                              );
                            });
                          } else {
                            Navigator.of(context).pushAndRemoveUntil(
                              MaterialPageRoute(
                                  builder: (_) => const MainAppShell()),
                              (route) => false,
                            );
                            // Open RequestServicePage for Ride or Pabili
                            Future.delayed(const Duration(milliseconds: 300),
                                () {
                              Navigator.of(context).push(
                                MaterialPageRoute(
                                  builder: (_) => RequestServicePage(
                                    initialServiceType: promo.applicableService,
                                  ),
                                ),
                              );
                            });
                          }
                        },
                        child: const Text('Use Promo'),
                      ),
                    ),
                  ],
                ),
              ),
            );
          },
        );
      },
    );
  }
}

class SupportScreen extends StatelessWidget {
  const SupportScreen({super.key});

  @override
  Widget build(BuildContext context) {
    final user = FirebaseAuth.instance.currentUser;
    return Scaffold(
      body: Center(
        child: Padding(
          padding: const EdgeInsets.all(24.0),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              const Icon(Icons.support_agent, size: 80, color: Colors.grey),
              const SizedBox(height: 16),
              const Text('Help & Support',
                  style: TextStyle(fontSize: 22, fontWeight: FontWeight.bold)),
              const SizedBox(height: 8),
              const Text(
                  'Our support team is here to help you.\nSupport hours: 8:00 AM - 10:00 PM',
                  textAlign: TextAlign.center),
              const SizedBox(height: 16),
              ElevatedButton.icon(
                icon: const Icon(Icons.chat_bubble_outline),
                label: const Text('Contact Support'),
                onPressed: () async {
                  if (user == null) {
                    ScaffoldMessenger.of(context).showSnackBar(
                      const SnackBar(
                          content: Text('Please log in to contact support.')),
                    );
                    return;
                  }
                  showModalBottomSheet(
                    context: context,
                    isScrollControlled: true,
                    shape: const RoundedRectangleBorder(
                      borderRadius:
                          BorderRadius.vertical(top: Radius.circular(20)),
                    ),
                    builder: (context) =>
                        SupportSelectOrderSheet(userId: user.uid),
                  );
                },
              ),
              const SizedBox(height: 24),
              TextButton.icon(
                icon: const Icon(Icons.help_outline),
                label: const Text('View FAQs'),
                onPressed: () {
                  showDialog(
                    context: context,
                    builder: (context) => AlertDialog(
                      title: const Text('FAQs'),
                      content: const Text(
                          '• How to book?\n• How to cancel?\n• How to use promos?\n\nFor more, visit our website.'),
                      actions: [
                        TextButton(
                          onPressed: () => Navigator.pop(context),
                          child: const Text('Close'),
                        )
                      ],
                    ),
                  );
                },
              ),
            ],
          ),
        ),
      ),
    );
  }
}

class SupportSelectOrderSheet extends StatefulWidget {
  final String userId;
  const SupportSelectOrderSheet({super.key, required this.userId});

  @override
  State<SupportSelectOrderSheet> createState() =>
      _SupportSelectOrderSheetState();
}

class _SupportSelectOrderSheetState extends State<SupportSelectOrderSheet> {
  ServiceType? _selectedService;
  String? _selectedOrderId;

  @override
  Widget build(BuildContext context) {
    return SafeArea(
      child: Padding(
        padding: EdgeInsets.only(
          left: 20,
          right: 20,
          top: 20,
          bottom: MediaQuery.of(context).viewInsets.bottom + 20,
        ),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            const Text('Contact Support',
                style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold)),
            const SizedBox(height: 16),
            DropdownButtonFormField<ServiceType>(
              value: _selectedService,
              decoration: const InputDecoration(labelText: 'Select Service'),
              items: [
                DropdownMenuItem(
                    value: ServiceType.food, child: Text('Food Delivery')),
                DropdownMenuItem(
                    value: ServiceType.ride, child: Text('Book a Ride')),
                DropdownMenuItem(
                    value: ServiceType.pabili, child: Text('Pabili')),
                DropdownMenuItem(value: null, child: Text('Other concern')),
              ],
              onChanged: (val) {
                setState(() {
                  _selectedService = val;
                  _selectedOrderId = null;
                });
              },
            ),
            if (_selectedService != null)
              FutureBuilder<QuerySnapshot>(
                future: FirebaseFirestore.instance
                    .collection('bookings')
                    .where('userId', isEqualTo: widget.userId)
                    .where('serviceType', isEqualTo: _selectedService!.name)
                    .orderBy('createdAt', descending: true)
                    .limit(10)
                    .get(),
                builder: (context, snapshot) {
                  if (!snapshot.hasData)
                    return const Padding(
                      padding: EdgeInsets.all(8.0),
                      child: CircularProgressIndicator(),
                    );
                  final docs = snapshot.data!.docs;
                  if (docs.isEmpty) {
                    return const Padding(
                      padding: EdgeInsets.all(8.0),
                      child: Text('No orders found for this service.'),
                    );
                  }
                  return DropdownButtonFormField<String>(
                    value: _selectedOrderId,
                    decoration: const InputDecoration(
                        labelText: 'Select Order (optional)'),
                    items: [
                      ...docs.map((doc) {
                        final data = doc.data() as Map<String, dynamic>;
                        final pickup = data['pickup']?['address'] ?? '';
                        final destination =
                            data['destination']?['address'] ?? '';
                        final createdAt =
                            (data['createdAt'] as Timestamp?)?.toDate();
                        return DropdownMenuItem(
                          value: doc.id,
                          child: Text(
                            '${pickup.toString().isNotEmpty ? pickup : 'Order'}'
                            '${destination.toString().isNotEmpty ? ' → $destination' : ''}'
                            '${createdAt != null ? ' (${createdAt.toLocal().toString().split(".").first})' : ''}',
                            overflow: TextOverflow.ellipsis,
                          ),
                        );
                      }),
                    ],
                    onChanged: (val) {
                      setState(() {
                        _selectedOrderId = val;
                      });
                    },
                  );
                },
              ),
            const SizedBox(height: 20),
            ElevatedButton.icon(
              icon: const Icon(Icons.chat),
              label: const Text('Start Chat'),
              onPressed: () {
                Navigator.pop(context); // Close the bottom sheet
                Navigator.of(context).push(
                  MaterialPageRoute(
                    builder: (_) => SupportChatScreen(
                      userId: widget.userId,
                      serviceType: _selectedService,
                      orderId: _selectedOrderId,
                    ),
                  ),
                );
              },
            ),
          ],
        ),
      ),
    );
  }
}

class SupportChatScreen extends StatelessWidget {
  final String userId;
  final ServiceType? serviceType;
  final String? orderId;
  const SupportChatScreen({
    super.key,
    required this.userId,
    this.serviceType,
    this.orderId,
  });

  String get chatId {
    // Unique chat per user+service+order
    if (orderId != null) {
      return '${userId}_${serviceType?.name ?? 'other'}_$orderId';
    } else if (serviceType != null) {
      return '${userId}_${serviceType!.name}';
    } else {
      return '${userId}_other';
    }
  }

  @override
  Widget build(BuildContext context) {
    final TextEditingController _msgController = TextEditingController();
    return Scaffold(
      appBar: AppBar(
        title: const Text('Support Chat'),
        actions: [
          IconButton(
            icon: const Icon(Icons.info_outline),
            onPressed: () {
              showDialog(
                context: context,
                builder: (context) => AlertDialog(
                  title: const Text('Support Info'),
                  content: Text(
                    'You are chatting about: '
                    '${serviceType == null ? 'Other concern' : serviceType == ServiceType.food ? 'Food Delivery' : serviceType == ServiceType.ride ? 'Book a Ride' : 'Pabili'}'
                    '${orderId != null ? '\nOrder ID: $orderId' : ''}\n\nSupport hours: 8:00 AM - 10:00 PM',
                  ),
                  actions: [
                    TextButton(
                      onPressed: () => Navigator.pop(context),
                      child: const Text('Close'),
                    )
                  ],
                ),
              );
            },
          )
        ],
      ),
      body: Column(
        children: [
          if (orderId != null)
            FutureBuilder<DocumentSnapshot>(
              future: FirebaseFirestore.instance
                  .collection('bookings')
                  .doc(orderId)
                  .get(),
              builder: (context, snap) {
                if (!snap.hasData) return const SizedBox();
                final data = snap.data!.data() as Map<String, dynamic>?;
                if (data == null) return const SizedBox();
                return ListTile(
                  title: Text(
                      'Order: ${data['pickup']?['address'] ?? ''} → ${data['destination']?['address'] ?? ''}'),
                  subtitle: Text('Status: ${data['status'] ?? ''}'),
                );
              },
            ),
          Expanded(
            child: StreamBuilder<QuerySnapshot>(
              stream: FirebaseFirestore.instance
                  .collection('supportChats')
                  .doc(chatId)
                  .collection('messages')
                  .orderBy('timestamp')
                  .snapshots(),
              builder: (context, snapshot) {
                if (!snapshot.hasData) {
                  return const Center(child: CircularProgressIndicator());
                }
                final messages = snapshot.data!.docs;
                if (messages.isEmpty) {
                  return const Center(
                      child: Text('No messages yet. Start the conversation!'));
                }
                return ListView.builder(
                  padding: const EdgeInsets.all(12),
                  itemCount: messages.length,
                  itemBuilder: (context, idx) {
                    final msg = messages[idx].data() as Map<String, dynamic>;
                    final isMe = msg['senderId'] == userId;
                    return Align(
                      alignment:
                          isMe ? Alignment.centerRight : Alignment.centerLeft,
                      child: Container(
                        margin: const EdgeInsets.symmetric(vertical: 4),
                        padding: const EdgeInsets.symmetric(
                            vertical: 8, horizontal: 14),
                        decoration: BoxDecoration(
                          color: isMe
                              ? Theme.of(context).primaryColor.withOpacity(0.9)
                              : Colors.grey[200],
                          borderRadius: BorderRadius.circular(16),
                        ),
                        child: Text(
                          msg['text'] ?? '',
                          style: TextStyle(
                            color: isMe ? Colors.white : Colors.black87,
                            fontSize: 15,
                          ),
                        ),
                      ),
                    );
                  },
                );
              },
            ),
          ),
          SafeArea(
            child: Padding(
              padding: const EdgeInsets.fromLTRB(12, 8, 12, 8),
              child: Row(
                children: [
                  Expanded(
                    child: Container(
                      decoration: BoxDecoration(
                        color: Colors.grey[100],
                        borderRadius: BorderRadius.circular(24),
                      ),
                      child: TextField(
                        controller: _msgController,
                        decoration: const InputDecoration(
                          hintText: 'Type your message...',
                          border: InputBorder.none,
                          contentPadding: EdgeInsets.symmetric(
                              horizontal: 16, vertical: 10),
                        ),
                        onSubmitted: (val) => _sendSupportMessage(
                            val, userId, chatId, _msgController),
                      ),
                    ),
                  ),
                  const SizedBox(width: 8),
                  CircleAvatar(
                    backgroundColor: Theme.of(context).primaryColor,
                    child: IconButton(
                      icon: const Icon(Icons.send, color: Colors.white),
                      onPressed: () => _sendSupportMessage(
                          _msgController.text, userId, chatId, _msgController),
                    ),
                  ),
                ],
              ),
            ),
          ),
        ],
      ),
    );
  }

  void _sendSupportMessage(String text, String userId, String chatId,
      TextEditingController controller) async {
    if (text.trim().isEmpty) return;
    await FirebaseFirestore.instance
        .collection('supportChats')
        .doc(chatId)
        .collection('messages')
        .add({
      'senderId': userId,
      'text': text.trim(),
      'timestamp': FieldValue.serverTimestamp(),
    });
    controller.clear();
  }
}

// In lib/main.dart, replace the placeholder CartScreen with this

class CartScreen extends StatelessWidget {
  const CartScreen({super.key});
  @override
  Widget build(BuildContext context) {
    // We now wrap the content in a Scaffold, which provides the Material canvas.
    return Scaffold(
      // The body uses a Consumer to listen for changes to the cart
      body: Consumer<CartProvider>(
        builder: (context, cart, child) {
          // If the cart is empty, show a centered message
          if (cart.items.isEmpty) {
            return const Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Icon(Icons.shopping_cart_outlined,
                      size: 80, color: Colors.grey),
                  SizedBox(height: 16),
                  Text('Your Cart is Empty',
                      style:
                          TextStyle(fontSize: 22, fontWeight: FontWeight.bold)),
                  Text('Add items from a store to see them here.',
                      style: TextStyle(color: Colors.grey)),
                ],
              ),
            );
          }

          // If the cart has items, build the list and checkout section
          return Column(
            children: [
              // The list of items is wrapped in Expanded to make it scrollable
              // and prevent overflow.
              Expanded(
                child: ListView.builder(
                  padding: const EdgeInsets.all(8),
                  itemCount: cart.items.length,
                  itemBuilder: (ctx, i) {
                    final cartItem = cart.items.values.toList()[i];
                    return Card(
                      margin: const EdgeInsets.symmetric(
                          horizontal: 8, vertical: 4),
                      child: ListTile(
                        leading: CircleAvatar(
                          child: Padding(
                            padding: const EdgeInsets.all(5),
                            child: FittedBox(
                                child: Text(
                                    '₱${cartItem.menuItem.price.toStringAsFixed(0)}')),
                          ),
                        ),
                        title: Text(cartItem.menuItem.name),
                        subtitle: Text(
                            'Total: ₱${(cartItem.menuItem.price * cartItem.quantity).toStringAsFixed(2)}'),
                        trailing: Text('${cartItem.quantity} x'),
                      ),
                    );
                  },
                ),
              ),
              // This is the summary section at the bottom
              Padding(
                padding: const EdgeInsets.all(16.0),
                child: Column(
                  children: [
                    Row(
                      mainAxisAlignment: MainAxisAlignment.spaceBetween,
                      children: [
                        const Text('Total:',
                            style: TextStyle(
                                fontSize: 20, fontWeight: FontWeight.bold)),
                        Chip(
                          label: Text(
                            'PHP ${cart.totalPrice.toStringAsFixed(2)}',
                            style: const TextStyle(
                                color: Colors.white,
                                fontWeight: FontWeight.bold),
                          ),
                          backgroundColor: Theme.of(context).primaryColor,
                        ),
                      ],
                    ),
                    const SizedBox(height: 10),
                    SizedBox(
                      width: double.infinity,
                      child: ElevatedButton(
                        onPressed: () {
                          Navigator.of(context).push(
                            MaterialPageRoute(
                              builder: (_) => const CheckoutScreen(),
                            ),
                          );
                        },
                        child: const Text('PROCEED TO CHECKOUT'),
                      ),
                    ),
                  ],
                ),
              ),
            ],
          );
        },
      ),
    );
  }
}

// Add this class after CartScreen or at the end of your file

class CheckoutScreen extends StatelessWidget {
  const CheckoutScreen({super.key});

  @override
  Widget build(BuildContext context) {
    final cart = Provider.of<CartProvider>(context, listen: false);
    final user = FirebaseAuth.instance.currentUser;
    final customerMobile = user?.phoneNumber ?? '';
    return Scaffold(
      appBar: AppBar(title: const Text('Checkout')),
      body: Padding(
        padding: const EdgeInsets.all(24.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            const Text('Order Summary',
                style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold)),
            const SizedBox(height: 16),
            Expanded(
              child: ListView(
                children: cart.items.values.map((item) {
                  return ListTile(
                    title: Text(item.menuItem.name),
                    subtitle: Text(
                        '${item.quantity} x ₱${item.menuItem.price.toStringAsFixed(2)}'),
                    trailing: Text(
                        '₱${(item.menuItem.price * item.quantity).toStringAsFixed(2)}'),
                  );
                }).toList(),
              ),
            ),
            const SizedBox(height: 16),
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                const Text('Total:',
                    style:
                        TextStyle(fontSize: 18, fontWeight: FontWeight.bold)),
                Text('₱${cart.totalPrice.toStringAsFixed(2)}',
                    style: const TextStyle(
                        fontSize: 18, fontWeight: FontWeight.bold)),
              ],
            ),
            const SizedBox(height: 24),
            ElevatedButton(
              onPressed: () async {
                if (user == null) {
                  ScaffoldMessenger.of(context).showSnackBar(
                    const SnackBar(
                        content: Text('Please log in to place an order.')),
                  );
                  return;
                }
                // Save order to Firestore
                await FirebaseFirestore.instance.collection('orders').add({
                  'userId': user.uid,
                  'items': cart.items.values
                      .map((item) => {
                            'name': item.menuItem.name,
                            'quantity': item.quantity,
                            'price': item.menuItem.price,
                            'customerMobile': customerMobile,
                          })
                      .toList(),
                  'total': cart.totalPrice,
                  'createdAt': FieldValue.serverTimestamp(),
                  'status': 'pending',
                });
                cart.clearCart();
                if (context.mounted) {
                  Navigator.of(context).popUntil((route) => route.isFirst);
                  ScaffoldMessenger.of(context).showSnackBar(
                    const SnackBar(content: Text('Order placed! Thank you.')),
                  );
                }
              },
              child: const Text('Place Order'),
            ),
          ],
        ),
      ),
    );
  }
}

class ActiveBookingPlaceholderScreen extends StatelessWidget {
  const ActiveBookingPlaceholderScreen({super.key});
  @override
  Widget build(BuildContext context) {
    return const Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(Icons.notifications_active_outlined,
              size: 80, color: Colors.grey),
          SizedBox(height: 16),
          Text('Active Booking Status'),
          Text('If you have an ongoing booking, its status will be shown here.',
              textAlign: TextAlign.center)
        ],
      ),
    );
  }
}

class StoreListingScreen extends StatefulWidget {
  const StoreListingScreen({Key? key}) : super(key: key);
  @override
  _StoreListingScreenState createState() => _StoreListingScreenState();
}

class _StoreListingScreenState extends State<StoreListingScreen> {
  String _searchQuery = "";
  final _searchController = TextEditingController();
  @override
  void initState() {
    super.initState();
    _searchController.addListener(() {
      if (mounted)
        setState(() {
          _searchQuery = _searchController.text.toLowerCase();
        });
    });
  }

  @override
  void dispose() {
    _searchController.dispose();
    super.dispose();
  }

  void _navigateToStoreMenu(Store store) {
    Navigator.push(context, MaterialPageRoute(builder: (context) {
      return StoreMenuScreen(store: store);
    }));
  }
  // In lib/main.dart, inside class _StoreListingScreenState

  @override
  Widget build(BuildContext context) {
    // ** FIX IS HERE: Returning a Scaffold **
    return Scaffold(
      appBar: AppBar(title: const Text('Food Delivery')),
      body: Column(
        children: [
          Padding(
            padding: const EdgeInsets.all(10.0),
            child: TextField(
              controller: _searchController,
              decoration: const InputDecoration(
                hintText: 'Search for stores or food...',
                prefixIcon: Icon(Icons.search),
              ),
            ),
          ),
          Padding(
            padding: const EdgeInsets.fromLTRB(16, 10, 16, 10),
            child: Text(
              'All Stores',
              style: Theme.of(context)
                  .textTheme
                  .titleLarge
                  ?.copyWith(fontWeight: FontWeight.bold),
            ),
          ),
          Expanded(
            child: StreamBuilder<QuerySnapshot>(
              stream:
                  FirebaseFirestore.instance.collection('stores').snapshots(),
              builder: (context, snapshot) {
                if (snapshot.connectionState == ConnectionState.waiting) {
                  return const Center(child: CircularProgressIndicator());
                }
                if (snapshot.hasError) {
                  return const Center(child: Text('Something went wrong!'));
                }
                if (!snapshot.hasData || snapshot.data!.docs.isEmpty) {
                  return const Center(child: Text('No stores available.'));
                }

                final storeDocs = snapshot.data!.docs.where((doc) {
                  final data = doc.data() as Map<String, dynamic>?;
                  if (data == null) return false;
                  final storeName =
                      (data['name'] as String?)?.toLowerCase() ?? '';
                  final cuisine =
                      (data['cuisine'] as String?)?.toLowerCase() ?? '';
                  return storeName.contains(_searchQuery) ||
                      cuisine.contains(_searchQuery);
                }).toList();

                if (storeDocs.isEmpty) {
                  return Center(
                      child: Text('No stores found for "$_searchQuery"'));
                }

                return ListView.builder(
                  padding: const EdgeInsets.only(
                      bottom: 80), // Padding to avoid overlap with FAB
                  itemCount: storeDocs.length,
                  itemBuilder: (context, index) {
                    final store = Store.fromFirestore(storeDocs[index]);
                    return Padding(
                      padding: const EdgeInsets.symmetric(
                          horizontal: 12.0, vertical: 8.0),
                      child: StoreListItem(
                        store: store,
                        onTap: () => _navigateToStoreMenu(store),
                      ),
                    );
                  },
                );
              },
            ),
          ),
        ],
      ),
      floatingActionButton: Consumer<CartProvider>(
        builder: (context, cart, child) {
          if (cart.itemCount == 0) {
            return const SizedBox.shrink();
          }
          return FloatingActionButton(
            onPressed: () {
              final mainAppShellState =
                  context.findAncestorStateOfType<_MainAppShellState>();
              mainAppShellState?._onItemTapped(2);
            },
            child: Stack(
              clipBehavior: Clip.none,
              children: [
                const Icon(Icons.shopping_cart_outlined, size: 28),
                if (cart.itemCount > 0)
                  Positioned(
                    top: -4,
                    right: -4,
                    child: Container(
                      padding: const EdgeInsets.symmetric(
                          horizontal: 6, vertical: 2),
                      decoration: BoxDecoration(
                        color: Colors.red,
                        borderRadius: BorderRadius.circular(12),
                        border: Border.all(color: Colors.white, width: 1),
                      ),
                      constraints: const BoxConstraints(
                        minWidth: 18,
                        minHeight: 18,
                      ),
                      child: Text(
                        '${cart.itemCount}',
                        style: const TextStyle(
                          color: Colors.white,
                          fontSize: 12,
                          fontWeight: FontWeight.bold,
                        ),
                        textAlign: TextAlign.center,
                      ),
                    ),
                  ),
              ],
            ),
          );
        },
      ),
    );
  }
}

class StoreListItem extends StatelessWidget {
  final Store store;
  final VoidCallback onTap;
  const StoreListItem({Key? key, required this.store, required this.onTap})
      : super(key: key);
  @override
  Widget build(BuildContext context) {
    return InkWell(
      onTap: onTap,
      child: Card(
        clipBehavior: Clip.antiAlias,
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Container(
                height: 140,
                decoration: BoxDecoration(
                    color: Colors.grey[300],
                    image: DecorationImage(
                        image: NetworkImage(store.imageUrl),
                        fit: BoxFit.cover))),
            Padding(
              padding: const EdgeInsets.all(12.0),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(store.name,
                      style: Theme.of(context).textTheme.titleLarge),
                  const SizedBox(height: 4),
                  Text(store.cuisine,
                      style: Theme.of(context).textTheme.bodyMedium),
                  const SizedBox(height: 8),
                  Row(
                    children: [
                      const Icon(Icons.star, color: Colors.amber, size: 16),
                      const SizedBox(width: 4),
                      Text(store.rating.toString(),
                          style: Theme.of(context)
                              .textTheme
                              .bodyMedium
                              ?.copyWith(fontWeight: FontWeight.bold)),
                      const SizedBox(width: 10),
                      Icon(Icons.timer_outlined,
                          color: Colors.grey[600], size: 16),
                      const SizedBox(width: 4),
                      Text(store.deliveryTime,
                          style: Theme.of(context).textTheme.bodyMedium),
                    ],
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }
}
// In lib/main.dart

class StoreMenuScreen extends StatelessWidget {
  final Store store;
  const StoreMenuScreen({Key? key, required this.store}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      // The body is now a Stack to layer the floating widget on top
      body: Stack(
        children: [
          CustomScrollView(
            slivers: <Widget>[
              SliverAppBar(
                expandedHeight: 200.0,
                pinned: true,
                flexibleSpace: FlexibleSpaceBar(
                  title: Text(store.name,
                      style: const TextStyle(
                          color: Colors.white,
                          fontWeight: FontWeight.bold,
                          shadows: [
                            Shadow(blurRadius: 2.0, color: Colors.black45)
                          ])),
                  background: Image.network(
                    store.imageUrl,
                    fit: BoxFit.cover,
                    color: Colors.black.withOpacity(0.3),
                    colorBlendMode: BlendMode.darken,
                  ),
                ),
              ),
              SliverToBoxAdapter(
                child: Padding(
                  padding: const EdgeInsets.all(16.0),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text("Menu",
                          style: Theme.of(context).textTheme.headlineMedium),
                      const SizedBox(height: 4),
                      Row(children: [
                        const Icon(Icons.star, color: Colors.amber, size: 18),
                        const SizedBox(width: 4),
                        Text(
                            '${store.rating}  •  ${store.cuisine}  •  ${store.deliveryTime}',
                            style: Theme.of(context).textTheme.bodyMedium),
                      ])
                    ],
                  ),
                ),
              ),
              SliverList(
                delegate: SliverChildBuilderDelegate(
                  (context, index) {
                    final menuItem = store.menu[index];
                    return MenuItemCard(menuItem: menuItem);
                  },
                  childCount: store.menu.length,
                ),
              ),
              // Add some padding at the bottom so the floating widget doesn't hide content
              const SliverToBoxAdapter(
                child: SizedBox(height: 100),
              )
            ],
          ),

          // This Consumer will show/hide the floating cart widget automatically
          Consumer<CartProvider>(builder: (context, cart, child) {
            if (cart.itemCount > 0) {
              return const FloatingCartWidget();
            }
            return const SizedBox.shrink(); // Show nothing if cart is empty
          }),
        ],
      ),
    );
  }
}

class MenuItemCard extends StatelessWidget {
  final MenuItem menuItem;
  const MenuItemCard({Key? key, required this.menuItem}) : super(key: key);
  @override
  Widget build(BuildContext context) {
    final cart = Provider.of<CartProvider>(context, listen: false);
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 10.0),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: <Widget>[
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: <Widget>[
                Text(menuItem.name,
                    style: Theme.of(context)
                        .textTheme
                        .titleLarge
                        ?.copyWith(fontSize: 17)),
                const SizedBox(height: 4),
                Text(menuItem.description,
                    style: Theme.of(context).textTheme.bodyMedium),
                const SizedBox(height: 8),
                Text('PHP ${menuItem.price.toStringAsFixed(2)}',
                    style: const TextStyle(
                        fontWeight: FontWeight.bold, fontSize: 16)),
              ],
            ),
          ),
          const SizedBox(width: 16),
          Column(
            children: [
              Container(
                width: 100,
                height: 80,
                decoration: BoxDecoration(
                  color: Colors.grey[200],
                  borderRadius: BorderRadius.circular(8.0),
                  image: DecorationImage(
                      image: NetworkImage(menuItem.imageUrl.isNotEmpty
                          ? menuItem.imageUrl
                          : "https://via.placeholder.com/100x80.png/F0F0F0/333333?Text=No+Image"),
                      fit: BoxFit.cover),
                ),
              ),
              const SizedBox(height: 8),
              SizedBox(
                width: 100,
                child: ElevatedButton(
                  onPressed: () {
                    cart.addToCart(menuItem);
                    ScaffoldMessenger.of(context).showSnackBar(
                      SnackBar(
                        content: Text('${menuItem.name} added to cart.'),
                        backgroundColor:
                            Theme.of(context).colorScheme.secondary,
                        duration: const Duration(seconds: 1),
                      ),
                    );
                  },
                  child: const Text('Add'),
                  style: ElevatedButton.styleFrom(
                      padding: const EdgeInsets.symmetric(vertical: 4),
                      shape: RoundedRectangleBorder(
                          borderRadius: BorderRadius.circular(8.0))),
                ),
              )
            ],
          )
        ],
      ),
    );
  }
}

// In lib/main.dart, add this new widget after the MenuItemCard class

// In FloatingCartWidget, update the onTap to open CartScreen:

class FloatingCartWidget extends StatelessWidget {
  const FloatingCartWidget({super.key});

  @override
  Widget build(BuildContext context) {
    return Consumer<CartProvider>(
      builder: (context, cart, child) {
        if (cart.itemCount == 0) {
          return const SizedBox.shrink();
        }
        return Positioned(
          bottom: 16 + MediaQuery.of(context).viewPadding.bottom,
          left: 16,
          right: 16,
          child: InkWell(
            onTap: () {
              Navigator.of(context).push(
                MaterialPageRoute(builder: (_) => const CartScreen()),
              );
            },
            child: Material(
              elevation: 8.0,
              borderRadius: BorderRadius.circular(15.0),
              child: Container(
                padding: const EdgeInsets.symmetric(
                    horizontal: 20.0, vertical: 12.0),
                decoration: BoxDecoration(
                  color: Theme.of(context).colorScheme.secondary,
                  borderRadius: BorderRadius.circular(15.0),
                ),
                child: Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    Row(
                      children: [
                        const Icon(Icons.shopping_cart, color: Colors.black),
                        const SizedBox(width: 8),
                        Container(
                          padding: const EdgeInsets.symmetric(
                              horizontal: 8, vertical: 2),
                          decoration: BoxDecoration(
                              color: Theme.of(context).primaryColor,
                              borderRadius: BorderRadius.circular(10)),
                          child: Text(
                            '${cart.itemCount}',
                            style: const TextStyle(
                                fontWeight: FontWeight.bold,
                                color: Colors.white,
                                fontSize: 14),
                          ),
                        ),
                      ],
                    ),
                    Text(
                      'View Cart | PHP ${cart.totalPrice.toStringAsFixed(2)}',
                      style: const TextStyle(
                          fontWeight: FontWeight.bold,
                          color: Colors.black,
                          fontSize: 16),
                    ),
                  ],
                ),
              ),
            ),
          ),
        );
      },
    );
  }
}

class ActiveBookingScreen extends StatefulWidget {
  final String bookingId;
  const ActiveBookingScreen({super.key, required this.bookingId});

  @override
  State<ActiveBookingScreen> createState() => _ActiveBookingScreenState();
}

class _ActiveBookingScreenState extends State<ActiveBookingScreen> {
  final TextEditingController _chatController = TextEditingController();

  void _sendMessage(String text, String userId) async {
    if (text.trim().isEmpty) return;
    await FirebaseFirestore.instance
        .collection('bookings')
        .doc(widget.bookingId)
        .collection('messages')
        .add({
      'senderId': userId,
      'text': text.trim(),
      'timestamp': FieldValue.serverTimestamp(),
    });
    _chatController.clear();
  }

  void _openChatModal(BuildContext context, User? user) {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (context) {
        return DraggableScrollableSheet(
          expand: false,
          initialChildSize: 0.8,
          minChildSize: 0.5,
          maxChildSize: 0.95,
          builder: (context, scrollController) {
            return Container(
              decoration: BoxDecoration(
                color: Colors.white,
                borderRadius:
                    const BorderRadius.vertical(top: Radius.circular(24)),
                boxShadow: [
                  BoxShadow(
                    color: Colors.black.withOpacity(0.08),
                    blurRadius: 12,
                    offset: const Offset(0, -2),
                  ),
                ],
              ),
              child: SafeArea(
                top: false,
                child: Column(
                  children: [
                    // Drag handle and close button
                    Padding(
                      padding: const EdgeInsets.only(
                          top: 12, left: 16, right: 16, bottom: 4),
                      child: Row(
                        children: [
                          Container(
                            width: 40,
                            height: 4,
                            decoration: BoxDecoration(
                              color: Colors.grey[300],
                              borderRadius: BorderRadius.circular(2),
                            ),
                          ),
                          const Spacer(),
                          IconButton(
                            icon: const Icon(Icons.close),
                            onPressed: () => Navigator.of(context).pop(),
                          ),
                        ],
                      ),
                    ),
                    // Driver info (optional)
                    Padding(
                      padding: const EdgeInsets.symmetric(
                          horizontal: 16, vertical: 4),
                      child: Row(
                        children: [
                          const CircleAvatar(
                            radius: 20,
                            backgroundColor: Colors.grey,
                            child: Icon(Icons.person, color: Colors.white),
                          ),
                          const SizedBox(width: 12),
                          Expanded(
                            child: Text(
                              "Driver",
                              style: Theme.of(context).textTheme.titleMedium,
                            ),
                          ),
                        ],
                      ),
                    ),
                    const Divider(height: 1),
                    // Chat area
                    Expanded(
                      child: StreamBuilder<QuerySnapshot>(
                        stream: FirebaseFirestore.instance
                            .collection('bookings')
                            .doc(widget.bookingId)
                            .collection('messages')
                            .orderBy('timestamp')
                            .snapshots(),
                        builder: (context, chatSnap) {
                          if (!chatSnap.hasData) {
                            return const Center(
                                child: CircularProgressIndicator());
                          }
                          final messages = chatSnap.data!.docs;
                          return ListView.builder(
                            controller: scrollController,
                            reverse: false,
                            padding: const EdgeInsets.symmetric(
                                vertical: 12, horizontal: 8),
                            itemCount: messages.length,
                            itemBuilder: (context, idx) {
                              final msg =
                                  messages[idx].data() as Map<String, dynamic>;
                              final isMe = msg['senderId'] ==
                                  FirebaseAuth.instance.currentUser?.uid;
                              return Align(
                                alignment: isMe
                                    ? Alignment.centerRight
                                    : Alignment.centerLeft,
                                child: Container(
                                  margin: EdgeInsets.only(
                                    top: 4,
                                    bottom: 4,
                                    left: isMe ? 40 : 0,
                                    right: isMe ? 0 : 40,
                                  ),
                                  padding: const EdgeInsets.symmetric(
                                      vertical: 10, horizontal: 14),
                                  decoration: BoxDecoration(
                                    color: isMe
                                        ? Theme.of(context)
                                            .primaryColor
                                            .withOpacity(0.9)
                                        : Colors.grey[200],
                                    borderRadius: BorderRadius.only(
                                      topLeft: const Radius.circular(18),
                                      topRight: const Radius.circular(18),
                                      bottomLeft:
                                          Radius.circular(isMe ? 18 : 4),
                                      bottomRight:
                                          Radius.circular(isMe ? 4 : 18),
                                    ),
                                    boxShadow: [
                                      if (isMe)
                                        BoxShadow(
                                          color: Colors.pink.withOpacity(0.08),
                                          blurRadius: 4,
                                          offset: const Offset(1, 2),
                                        ),
                                    ],
                                  ),
                                  child: Text(
                                    msg['text'] ?? '',
                                    style: TextStyle(
                                      color:
                                          isMe ? Colors.white : Colors.black87,
                                      fontSize: 15,
                                    ),
                                  ),
                                ),
                              );
                            },
                          );
                        },
                      ),
                    ),
                    // Input area
                    Padding(
                      padding: EdgeInsets.only(
                        left: 12,
                        right: 12,
                        bottom: MediaQuery.of(context).viewInsets.bottom +
                            MediaQuery.of(context).padding.bottom +
                            12,
                        top: 8,
                      ),
                      child: Row(
                        children: [
                          Expanded(
                            child: Container(
                              decoration: BoxDecoration(
                                color: Colors.grey[100],
                                borderRadius: BorderRadius.circular(24),
                              ),
                              child: TextField(
                                controller: _chatController,
                                decoration: const InputDecoration(
                                  hintText: 'Type a message...',
                                  border: InputBorder.none,
                                  contentPadding: EdgeInsets.symmetric(
                                      horizontal: 16, vertical: 10),
                                ),
                                onSubmitted: (val) => _sendMessage(val,
                                    FirebaseAuth.instance.currentUser!.uid),
                              ),
                            ),
                          ),
                          const SizedBox(width: 8),
                          CircleAvatar(
                            backgroundColor: Theme.of(context).primaryColor,
                            child: IconButton(
                              icon: const Icon(Icons.send, color: Colors.white),
                              onPressed: () => _sendMessage(
                                  _chatController.text,
                                  FirebaseAuth.instance.currentUser!.uid),
                            ),
                          ),
                        ],
                      ),
                    ),
                  ],
                ),
              ),
            );
          },
        );
      },
    );
  }

  Future<void> _cancelCurrentOperation() async {
    final user = FirebaseAuth.instance.currentUser;
    if (user == null) return;
    final bookingSnap = await FirebaseFirestore.instance
        .collection('bookings')
        .where('userId', isEqualTo: user.uid)
        .where('status', isEqualTo: 'active')
        .limit(1)
        .get();

    if (bookingSnap.docs.isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('No active booking found.')),
      );
      return;
    }

    final bookingData = bookingSnap.docs.first.data();
    final bookingId = bookingSnap.docs.first.id;
    final driverAssigned = bookingData['driver'] != null &&
        bookingData['driver'].toString().isNotEmpty;

    if (driverAssigned) {
      final confirm = await showDialog<bool>(
        context: context,
        builder: (context) => AlertDialog(
          title: const Text('Driver Already Assigned'),
          content: const Text(
            'A driver has already accepted your booking. '
            'Cancelling now may inconvenience the driver and could result in a cancellation fee. '
            'Are you sure you want to cancel?',
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.of(context).pop(false),
              child: const Text('No'),
            ),
            TextButton(
              onPressed: () => Navigator.of(context).pop(true),
              child: const Text('Yes, Cancel'),
            ),
          ],
        ),
      );
      if (confirm != true) return;
    }

    final reasons = [
      'Change of plans',
      'Waited too long',
      'Driver not moving',
      'Booked by mistake',
      'Other'
    ];
    String? selectedReason = await showDialog<String>(
      context: context,
      builder: (context) {
        String? tempReason;
        return AlertDialog(
          title: const Text('Cancel Booking'),
          content: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              ...reasons.map((reason) => RadioListTile<String>(
                    title: Text(reason),
                    value: reason,
                    groupValue: tempReason,
                    onChanged: (val) {
                      tempReason = val;
                      setState(() {});
                      Navigator.of(context).pop(val);
                    },
                  )),
            ],
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.of(context).pop(null),
              child: const Text('Close'),
            ),
          ],
        );
      },
    );

    if (selectedReason == null) return;

    try {
      await FirebaseFirestore.instance
          .collection('bookings')
          .doc(bookingId)
          .update({
        'cancellationRequested': true,
        'cancellationReason': selectedReason,
        'cancellationStatus': 'pending',
        'status': 'cancelled',
        'cancelledAt': FieldValue.serverTimestamp(),
      });

      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Booking cancelled.')),
      );

      // Optionally, navigate back to home or activity screen
      Navigator.of(context).pushAndRemoveUntil(
        MaterialPageRoute(builder: (_) => const MainAppShell()),
        (route) => false,
      );
    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Failed to cancel booking: $e')),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    final user = FirebaseAuth.instance.currentUser;
    return StreamBuilder<DocumentSnapshot>(
      stream: FirebaseFirestore.instance
          .collection('bookings')
          .doc(widget.bookingId)
          .snapshots(),
      builder: (context, snapshot) {
        if (!snapshot.hasData) {
          return const Scaffold(
              body: Center(child: CircularProgressIndicator()));
        }
        final data = snapshot.data!.data() as Map<String, dynamic>;
        final driver = data['driver'] ?? {};
        final status = (data['status'] ?? '').toString();
        final fare = data['fare'] ?? '';
        final pickup = data['pickup']?['address'] ?? '';
        final destination = data['destination']?['address'] ?? '';
        final pickupLat = data['pickup']?['lat'];
        final pickupLng = data['pickup']?['lng'];
        final destLat = data['destination']?['lat'];
        final destLng = data['destination']?['lng'];
        final riderLat = data['rider']?['lat'];
        final riderLng = data['rider']?['lng'];

        // Markers for map
        Set<gmaps.Marker> markers = {};
        if (pickupLat != null && pickupLng != null) {
          markers.add(gmaps.Marker(
            markerId: const gmaps.MarkerId('pickup'),
            position: gmaps.LatLng(pickupLat, pickupLng),
            icon: gmaps.BitmapDescriptor.defaultMarkerWithHue(
                gmaps.BitmapDescriptor.hueRed),
            infoWindow: const gmaps.InfoWindow(title: 'Pickup'),
          ));
        }
        if (destLat != null && destLng != null) {
          markers.add(gmaps.Marker(
            markerId: const gmaps.MarkerId('destination'),
            position: gmaps.LatLng(destLat, destLng),
            icon: gmaps.BitmapDescriptor.defaultMarkerWithHue(
                gmaps.BitmapDescriptor.hueBlue),
            infoWindow: const gmaps.InfoWindow(title: 'Destination'),
          ));
        }
        if (riderLat != null && riderLng != null) {
          markers.add(gmaps.Marker(
            markerId: const gmaps.MarkerId('rider'),
            position: gmaps.LatLng(riderLat, riderLng),
            icon: gmaps.BitmapDescriptor.defaultMarkerWithHue(
                gmaps.BitmapDescriptor.hueGreen),
            infoWindow: const gmaps.InfoWindow(title: 'Rider'),
          ));
        }

        // Center map on rider if available, else pickup, else Cebu
        gmaps.LatLng mapCenter = const gmaps.LatLng(10.3157, 123.8854);
        if (riderLat != null && riderLng != null) {
          mapCenter = gmaps.LatLng(riderLat, riderLng);
        } else if (pickupLat != null && pickupLng != null) {
          mapCenter = gmaps.LatLng(pickupLat, pickupLng);
        }

        // Determine if driver is assigned
        final bool driverAssigned = driver is Map && driver.isNotEmpty;
        final bool isCancelled = status == 'cancelled';
        final bool isCompleted = status == 'completed';

        return Scaffold(
          appBar: AppBar(
            title: const Text('Active Booking'),
            automaticallyImplyLeading: false,
            actions: [
              IconButton(
                icon: const Icon(Icons.home),
                tooltip: 'Back to Home',
                onPressed: () {
                  Navigator.of(context).pushAndRemoveUntil(
                    MaterialPageRoute(builder: (_) => const MainAppShell()),
                    (route) => false,
                  );
                },
              ),
            ],
          ),
          resizeToAvoidBottomInset: true,
          floatingActionButton: (status == 'active' &&
                  !driverAssigned &&
                  !isCancelled &&
                  !isCompleted)
              ? FloatingActionButton.extended(
                  icon: const Icon(Icons.cancel),
                  label: const Text('Cancel'),
                  backgroundColor: Colors.red,
                  onPressed: _cancelCurrentOperation,
                )
              : FloatingActionButton.extended(
                  icon: const Icon(Icons.chat_bubble_outline),
                  label: const Text('Chat'),
                  onPressed: () => _openChatModal(context, user),
                ),
          body: SafeArea(
            child: Column(
              children: [
                // Map section
                SizedBox(
                  height: MediaQuery.of(context).size.height * 0.25,
                  child: gmaps.GoogleMap(
                    initialCameraPosition: gmaps.CameraPosition(
                      target: mapCenter,
                      zoom: 14,
                    ),
                    markers: markers,
                    myLocationEnabled: true,
                    myLocationButtonEnabled: true,
                    zoomControlsEnabled: false,
                  ),
                ),
                // Status section
                Padding(
                  padding: const EdgeInsets.all(16.0),
                  child: Row(
                    children: [
                      if (!driverAssigned && status == 'active') ...[
                        const CircularProgressIndicator(),
                        const SizedBox(width: 12),
                        const Text(
                          "Finding a rider...",
                          style: TextStyle(
                              fontSize: 16, fontWeight: FontWeight.bold),
                        ),
                      ] else if (driverAssigned && status == 'active') ...[
                        const Icon(Icons.check_circle, color: Colors.green),
                        const SizedBox(width: 8),
                        const Text(
                          "Driver Accepted",
                          style: TextStyle(
                              fontSize: 16,
                              fontWeight: FontWeight.bold,
                              color: Colors.green),
                        ),
                      ] else if (isCancelled) ...[
                        const Icon(Icons.cancel, color: Colors.red),
                        const SizedBox(width: 8),
                        const Text(
                          "Booking Cancelled",
                          style: TextStyle(
                              fontSize: 16,
                              fontWeight: FontWeight.bold,
                              color: Colors.red),
                        ),
                      ] else if (isCompleted) ...[
                        const Icon(Icons.check, color: Colors.blueGrey),
                        const SizedBox(width: 8),
                        const Text(
                          "Trip Completed",
                          style: TextStyle(
                              fontSize: 16,
                              fontWeight: FontWeight.bold,
                              color: Colors.blueGrey),
                        ),
                      ]
                    ],
                  ),
                ),
                // Booking info section
                ListTile(
                  leading: const Icon(Icons.person, size: 40),
                  title: Text(driver['name'] ?? 'Driver'),
                  subtitle: Text(
                      '${driver['vehicle'] ?? ''} (${driver['plate'] ?? ''})'),
                  trailing: Text(
                    status.toUpperCase(),
                    style: TextStyle(
                      color: status == 'active'
                          ? Colors.green
                          : status == 'cancelled'
                              ? Colors.red
                              : Colors.grey,
                    ),
                  ),
                ),
                ListTile(
                  leading: const Icon(Icons.location_on),
                  title: Text('Pickup: $pickup'),
                ),
                ListTile(
                  leading: const Icon(Icons.flag),
                  title: Text('Destination: $destination'),
                ),
                ListTile(
                  leading: const Icon(Icons.attach_money),
                  title: Text('Fare: $fare'),
                ),
                const Divider(),
              ],
            ),
          ),
        );
      },
    );
  }
}
// ... (keep all code above unchanged) ...

class RequestServicePage extends StatefulWidget {
  final ServiceType initialServiceType;
  const RequestServicePage({Key? key, required this.initialServiceType})
      : super(key: key);
  @override
  _RequestServicePageState createState() => _RequestServicePageState();
}

class _RequestServicePageState extends State<RequestServicePage> {
  late ServiceType _selectedService;
  late bool _isPabiliSelected;
  final TextEditingController _pickupController = TextEditingController();
  final TextEditingController _destinationController = TextEditingController();
  final TextEditingController _itemDescriptionController =
      TextEditingController();
  final TextEditingController _estimatedCostController =
      TextEditingController();

  // Add the missing variable here

  gmaps.GoogleMapController? _googleMapController;
  gmaps.LatLng _currentMapCenter = const gmaps.LatLng(10.3157, 123.8854);
  double _currentMapZoom = 13.0;
  gmaps.LatLng? _pickupLatLng;
  gmaps.LatLng? _destinationLatLng;
  gmaps.LatLng? _simulatedRiderPosition;
  List<gmaps.LatLng> _routePolylinePoints = [];
  String _estimatedDuration = "";
  bool _isFetchingRoute = false;
  String _estimatedFareMessage = "";
  bool _calculatingFare = false;
  bool _waitingDialogShown = false;
  static const double _baseFare = 10.0;
  static const double _ratePerKm = 8.0;
  static const double _ratePerMinute = 1.0;
  static const double _minimumFare = 50.0;
  String _mapMessage = "Use GPS for pickup or tap fields to search.";
  bool _isSearchingForRider = false;
  String _searchStatusMessage = "";
  String _riderDetails = "";
  Timer? _riderSimulationTimer;
  String _simulationNotificationMessage = "";

  StreamSubscription<QuerySnapshot>? _bookingListener;

  @override
  void initState() {
    super.initState();
    _selectedService = widget.initialServiceType;
    _isPabiliSelected = (_selectedService == ServiceType.pabili);
    // Listen for booking updates
    final user = FirebaseAuth.instance.currentUser;
    if (user != null) {
      _bookingListener = FirebaseFirestore.instance
          .collection('bookings')
          .where('userId', isEqualTo: user.uid)
          .where('status', isEqualTo: 'active')
          .snapshots()
          .listen((snapshot) {
        if (snapshot.docs.isNotEmpty) {
          final data = snapshot.docs.first.data();
          final driver = data['driver'];
          print('DEBUG: driver field value: $driver');
          if (driver is Map &&
              driver['name'] != null &&
              (driver['name'] as String).trim().isNotEmpty &&
              data['status'] == 'active' &&
              _waitingDialogShown) {
            Navigator.of(context, rootNavigator: true).pop();
            _waitingDialogShown = false;
            setState(() {
              _isSearchingForRider = false;
              _searchStatusMessage = "Driver assigned! Please wait for pickup.";
            });
            // Navigate to ActiveBookingScreen
            Future.delayed(const Duration(milliseconds: 300), () {
              Navigator.of(context).pushReplacement(
                MaterialPageRoute(
                  builder: (_) =>
                      ActiveBookingScreen(bookingId: snapshot.docs.first.id),
                ),
              );
            });
          }
        }
      });
    }
  }

  void _showWaitingForRiderDialog() {
    bool showBoost = false;
    _waitingDialogShown = true;
    Timer? boostTimer;

    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (context) {
        return StatefulBuilder(
          builder: (context, setState) {
            if (boostTimer == null) {
              boostTimer = Timer(const Duration(minutes: 1), () {
                setState(() {
                  showBoost = true;
                });
              });
            }
            return AlertDialog(
              shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(16)),
              contentPadding: const EdgeInsets.all(24),
              content: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  const SizedBox(height: 8),
                  const CircularProgressIndicator(),
                  const SizedBox(height: 24),
                  const Text(
                    "Looking for a rider...",
                    style: TextStyle(fontWeight: FontWeight.bold, fontSize: 18),
                    textAlign: TextAlign.center,
                  ),
                  const SizedBox(height: 12),
                  const Text(
                    "Please wait while we find a nearby rider to accept your request.",
                    textAlign: TextAlign.center,
                  ),
                  if (showBoost) ...[
                    const SizedBox(height: 24),
                    const Text(
                      "Boost your fare to get a rider faster?",
                      style: TextStyle(fontWeight: FontWeight.bold),
                    ),
                    const SizedBox(height: 12),
                    Wrap(
                      spacing: 10,
                      children: [10, 20, 30, 40, 50].map((amount) {
                        return ElevatedButton(
                          style: ElevatedButton.styleFrom(
                            backgroundColor: Colors.orange,
                            foregroundColor: Colors.white,
                            shape: RoundedRectangleBorder(
                              borderRadius: BorderRadius.circular(20),
                            ),
                          ),
                          onPressed: () {
                            Navigator.of(context).pop();
                            boostTimer?.cancel();
                            _applyBoost(amount);
                          },
                          child: Text("+₱$amount"),
                        );
                      }).toList(),
                    ),
                  ],
                  const SizedBox(height: 16),
                  TextButton(
                    onPressed: () {
                      Navigator.of(context).pop();
                      boostTimer?.cancel();
                      _cancelCurrentOperation();
                    },
                    child: const Text("Cancel"),
                  ),
                ],
              ),
            );
          },
        );
      },
    ).then((_) {
      boostTimer?.cancel();
      _waitingDialogShown = false;
    });
  }

  void _applyBoost(int amount) async {
    final user = FirebaseAuth.instance.currentUser;
    if (user == null) return;
    final bookingSnap = await FirebaseFirestore.instance
        .collection('bookings')
        .where('userId', isEqualTo: user.uid)
        .where('status', isEqualTo: 'active')
        .limit(1)
        .get();

    if (bookingSnap.docs.isNotEmpty) {
      final bookingId = bookingSnap.docs.first.id;
      await FirebaseFirestore.instance
          .collection('bookings')
          .doc(bookingId)
          .update({'boost': amount});
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Boosted fare by ₱$amount!')),
      );
    }
  }

  void _handleMapTap(gmaps.LatLng tappedPoint) {
    setState(() {
      if (_pickupLatLng == null) {
        _pickupLatLng = tappedPoint;
        _pickupController.text =
            "Pinned Location (${tappedPoint.latitude.toStringAsFixed(5)}, ${tappedPoint.longitude.toStringAsFixed(5)})";
        _mapMessage = "Pickup set. Tap again to set destination.";
      } else if (_destinationLatLng == null) {
        _destinationLatLng = tappedPoint;
        _destinationController.text =
            "Pinned Location (${tappedPoint.latitude.toStringAsFixed(5)}, ${tappedPoint.longitude.toStringAsFixed(5)})";
        _mapMessage = "Pickup and destination set. You can now request a ride.";
      } else {
        _pickupLatLng = tappedPoint;
        _destinationLatLng = null;
        _pickupController.text =
            "Pinned Location (${tappedPoint.latitude.toStringAsFixed(5)}, ${tappedPoint.longitude.toStringAsFixed(5)})";
        _destinationController.clear();
        _mapMessage = "Pickup reset. Tap again to set destination.";
      }
    });
  }

  Future<void> _getCurrentLocationAndSetPickup() async {
    try {
      Position position = await Geolocator.getCurrentPosition(
          desiredAccuracy: LocationAccuracy.high);
      setState(() {
        _pickupLatLng = gmaps.LatLng(position.latitude, position.longitude);
        _pickupController.text =
            "Current Location (${position.latitude.toStringAsFixed(5)}, ${position.longitude.toStringAsFixed(5)})";
        _mapMessage =
            "Pickup set to your current location. Tap again to set destination.";
      });
      if (_googleMapController != null) {
        _googleMapController!.animateCamera(
          gmaps.CameraUpdate.newLatLng(_pickupLatLng!),
        );
      }
    } catch (e) {
      setState(() {
        _mapMessage = "Failed to get current location: $e";
      });
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text("Failed to get current location: $e")),
      );
    }
  }

  void _navigateToSearchScreen(String type) async {
    final result = await Navigator.push(
      context,
      MaterialPageRoute(
        builder: (context) => LocationSearchScreen(locationType: type),
      ),
    );
    if (result != null && result is Map<String, dynamic>) {
      setState(() {
        if (type == "pickup") {
          _pickupController.text = result['address'] ?? '';
          _pickupLatLng = result['latLng'];
          _mapMessage = "Pickup set. Tap again to set destination.";
        } else if (type == "destination") {
          _destinationController.text = result['address'] ?? '';
          _destinationLatLng = result['latLng'];
          _mapMessage =
              "Pickup and destination set. You can now request a ride.";
        }
      });

      if (_pickupLatLng != null && _destinationLatLng != null) {
        _calculateFareAndRoute();
      }
      if (_googleMapController != null && result['latLng'] != null) {
        _googleMapController!.animateCamera(
          gmaps.CameraUpdate.newLatLng(result['latLng']),
        );
      }
    }
  }

  Future<void> _calculateFareAndRoute() async {
    if (_pickupLatLng == null || _destinationLatLng == null) return;

    setState(() {
      _calculatingFare = true;
      _estimatedFareMessage = "";
      _isFetchingRoute = true;
      _estimatedDuration = "";
      _routePolylinePoints = [];
    });

    final apiKey =
        'AIzaSyAY2ateXTWXgThNsfZQkqIi6ZzWWcwNazE'; // Your Google Directions API key
    final url =
        'https://maps.googleapis.com/maps/api/directions/json?origin=${_pickupLatLng!.latitude},${_pickupLatLng!.longitude}&destination=${_destinationLatLng!.latitude},${_destinationLatLng!.longitude}&mode=driving&key=$apiKey';

    try {
      final response = await http.get(Uri.parse(url));
      final data = json.decode(response.body);

      if (data['status'] == 'OK') {
        final route = data['routes'][0];
        final leg = route['legs'][0];

        final distanceMeters = leg['distance']['value'];
        final durationSeconds = leg['duration']['value'];
        final distanceKm = distanceMeters / 1000.0;
        final durationMin = durationSeconds / 60.0;

        final polyline = route['overview_polyline']['points'];
        _routePolylinePoints = _decodePolyline(polyline);

        double fare = _baseFare +
            (distanceKm * _ratePerKm) +
            (durationMin * _ratePerMinute);
        if (fare < _minimumFare) fare = _minimumFare;

        setState(() {
          _calculatingFare = false;
          _isFetchingRoute = false;
          _estimatedFareMessage = "Est. Fare: ₱${fare.toStringAsFixed(2)}";
          _estimatedDuration = "Est. Duration: ${leg['duration']['text']}";
        });
      } else {
        setState(() {
          _calculatingFare = false;
          _isFetchingRoute = false;
          _estimatedFareMessage = "Could not calculate fare. Try again.";
        });
      }
    } catch (e) {
      setState(() {
        _calculatingFare = false;
        _isFetchingRoute = false;
        _estimatedFareMessage = "Error calculating fare.";
      });
    }
  }

  List<gmaps.LatLng> _decodePolyline(String encoded) {
    List<gmaps.LatLng> polyline = [];
    int index = 0, len = encoded.length;
    int lat = 0, lng = 0;

    while (index < len) {
      int b, shift = 0, result = 0;
      do {
        b = encoded.codeUnitAt(index++) - 63;
        result |= (b & 0x1f) << shift;
        shift += 5;
      } while (b >= 0x20);
      int dlat = ((result & 1) != 0 ? ~(result >> 1) : (result >> 1));
      lat += dlat;

      shift = 0;
      result = 0;
      do {
        b = encoded.codeUnitAt(index++) - 63;
        result |= (b & 0x1f) << shift;
        shift += 5;
      } while (b >= 0x20);
      int dlng = ((result & 1) != 0 ? ~(result >> 1) : (result >> 1));
      lng += dlng;

      polyline.add(gmaps.LatLng(lat / 1E5, lng / 1E5));
    }
    return polyline;
  }

  @override
  Widget build(BuildContext context) {
    Set<gmaps.Marker> allMarkers = {};
    if (_pickupLatLng != null) {
      allMarkers.add(
        gmaps.Marker(
          markerId: const gmaps.MarkerId('pickup'),
          position: _pickupLatLng!,
          icon: gmaps.BitmapDescriptor.defaultMarkerWithHue(
              gmaps.BitmapDescriptor.hueRed),
          infoWindow: const gmaps.InfoWindow(title: 'Pickup'),
        ),
      );
    }
    if (_destinationLatLng != null) {
      allMarkers.add(
        gmaps.Marker(
          markerId: const gmaps.MarkerId('destination'),
          position: _destinationLatLng!,
          icon: gmaps.BitmapDescriptor.defaultMarkerWithHue(
              gmaps.BitmapDescriptor.hueBlue),
          infoWindow: const gmaps.InfoWindow(title: 'Destination'),
        ),
      );
    }
    if (_simulatedRiderPosition != null) {
      allMarkers.add(
        gmaps.Marker(
          markerId: const gmaps.MarkerId('rider'),
          position: _simulatedRiderPosition!,
          icon: gmaps.BitmapDescriptor.defaultMarkerWithHue(
              gmaps.BitmapDescriptor.hueGreen),
          infoWindow: const gmaps.InfoWindow(title: 'Rider'),
        ),
      );
    }

    Set<gmaps.Polyline> polylines = {};
    if (_routePolylinePoints.isNotEmpty) {
      polylines.add(
        gmaps.Polyline(
          polylineId: const gmaps.PolylineId('route'),
          color: Theme.of(context).colorScheme.secondary,
          width: 5,
          points: _routePolylinePoints,
        ),
      );
    }

    bool isCurrentlyInteractive =
        !(_isSearchingForRider || _simulatedRiderPosition != null);
    bool isTripActive = _simulatedRiderPosition != null;

    return Scaffold(
      appBar: AppBar(
        title: Text(
            'GoHatod - ${_selectedService.name[0].toUpperCase()}${_selectedService.name.substring(1)}'),
      ),
      body: SafeArea(
        child: Column(
          children: <Widget>[
            SizedBox(
              height: MediaQuery.of(context).size.height * 0.4,
              child: gmaps.GoogleMap(
                initialCameraPosition: gmaps.CameraPosition(
                  target: _pickupLatLng ?? _currentMapCenter,
                  zoom: _currentMapZoom,
                ),
                markers: allMarkers,
                polylines: polylines,
                myLocationEnabled: true,
                myLocationButtonEnabled: true,
                onTap: isCurrentlyInteractive ? _handleMapTap : null,
                onMapCreated: (controller) {
                  _googleMapController = controller;
                },
              ),
            ),
            Expanded(
              child: SingleChildScrollView(
                padding: EdgeInsets.fromLTRB(
                  16.0,
                  16.0,
                  16.0,
                  24.0 + MediaQuery.of(context).viewPadding.bottom,
                ),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.stretch,
                  children: <Widget>[
                    if (_simulationNotificationMessage.isNotEmpty)
                      Container(
                        padding: const EdgeInsets.symmetric(
                            vertical: 8.0, horizontal: 12.0),
                        margin: const EdgeInsets.only(bottom: 8.0),
                        decoration: BoxDecoration(
                          color: Theme.of(context)
                              .colorScheme
                              .secondary
                              .withOpacity(0.15),
                          borderRadius: BorderRadius.circular(8.0),
                          border: Border.all(
                              color: Theme.of(context)
                                  .colorScheme
                                  .secondary
                                  .withOpacity(0.4)),
                        ),
                        child: Text(
                          _simulationNotificationMessage,
                          style: TextStyle(
                              fontSize: 15,
                              color: Theme.of(context).colorScheme.secondary,
                              fontWeight: FontWeight.w600),
                          textAlign: TextAlign.center,
                        ),
                      )
                    else if (_calculatingFare)
                      Padding(
                          padding: const EdgeInsets.only(bottom: 8.0),
                          child: Row(
                              mainAxisAlignment: MainAxisAlignment.center,
                              children: [
                                const SizedBox(
                                    height: 16,
                                    width: 16,
                                    child: CircularProgressIndicator(
                                        strokeWidth: 2)),
                                const SizedBox(width: 8),
                                const Text("Calculating fare...",
                                    style: TextStyle(
                                        fontSize: 14, color: Colors.blueGrey))
                              ]))
                    else if (_estimatedFareMessage.isNotEmpty)
                      Padding(
                        padding: const EdgeInsets.only(bottom: 8.0),
                        child: Text(
                          _estimatedFareMessage,
                          style: TextStyle(
                              fontSize: 16,
                              color: Colors.green[700],
                              fontWeight: FontWeight.bold),
                          textAlign: TextAlign.center,
                        ),
                      )
                    else if (_estimatedDuration.isNotEmpty && !_isFetchingRoute)
                      Padding(
                        padding: const EdgeInsets.only(bottom: 8.0),
                        child: Text(
                          _estimatedDuration,
                          style: const TextStyle(
                              fontSize: 15,
                              color: Colors.teal,
                              fontWeight: FontWeight.bold),
                          textAlign: TextAlign.center,
                        ),
                      )
                    else if (_isFetchingRoute)
                      Padding(
                          padding: const EdgeInsets.only(bottom: 8.0),
                          child: Row(
                              mainAxisAlignment: MainAxisAlignment.center,
                              children: [
                                const SizedBox(
                                    height: 16,
                                    width: 16,
                                    child: CircularProgressIndicator(
                                        strokeWidth: 2)),
                                Text(_estimatedDuration,
                                    style: const TextStyle(
                                        fontSize: 14, color: Colors.blueGrey))
                              ]))
                    else if (_mapMessage.isNotEmpty && isCurrentlyInteractive)
                      Padding(
                        padding: const EdgeInsets.only(bottom: 8.0),
                        child: Text(_mapMessage,
                            style: const TextStyle(
                                fontSize: 14, color: Colors.blueGrey),
                            textAlign: TextAlign.center),
                      ),
                    if (isCurrentlyInteractive) ...[
                      ElevatedButton.icon(
                          icon: const Icon(Icons.my_location, size: 18),
                          label: const Text('Use Current Location for Pickup'),
                          onPressed: _getCurrentLocationAndSetPickup,
                          style: ElevatedButton.styleFrom(
                              backgroundColor:
                                  Theme.of(context).colorScheme.secondary,
                              foregroundColor: Colors.black,
                              padding:
                                  const EdgeInsets.symmetric(vertical: 10))),
                      const SizedBox(height: 16),
                      TextFormField(
                        controller: _pickupController,
                        readOnly: true,
                        onTap: () => _navigateToSearchScreen("pickup"),
                        decoration: const InputDecoration(
                            labelText: 'Pickup Location',
                            hintText: 'Tap to search pickup',
                            prefixIcon: Icon(Icons.trip_origin)),
                      ),
                      const SizedBox(height: 12),
                      TextFormField(
                        controller: _destinationController,
                        readOnly: true,
                        onTap: () => _navigateToSearchScreen("destination"),
                        decoration: const InputDecoration(
                            labelText: 'Destination Location',
                            hintText: 'Tap to search destination',
                            prefixIcon: Icon(Icons.flag_outlined)),
                      ),
                      const SizedBox(height: 12),
                      if (_isPabiliSelected) ...[
                        TextFormField(
                          controller: _itemDescriptionController,
                          decoration: const InputDecoration(
                              labelText: 'Item(s) to Pickup',
                              prefixIcon: Icon(Icons.shopping_bag_outlined)),
                          maxLines: 2,
                        ),
                        const SizedBox(height: 12),
                        TextFormField(
                          controller: _estimatedCostController,
                          decoration: const InputDecoration(
                              labelText: 'Estimated Cost (₱)',
                              prefixIcon: Icon(Icons.payments_outlined)),
                          keyboardType: TextInputType.number,
                        ),
                        const SizedBox(height: 12),
                      ],
                    ],
                    const SizedBox(height: 12),
                    if (_isSearchingForRider)
                      Padding(
                        padding: const EdgeInsets.symmetric(vertical: 8.0),
                        child: Row(
                          mainAxisAlignment: MainAxisAlignment.center,
                          children: [
                            SizedBox(
                                height: 20,
                                width: 20,
                                child: CircularProgressIndicator(
                                    strokeWidth: 2.5,
                                    color: Theme.of(context).primaryColor)),
                            const SizedBox(width: 12),
                            Text(_searchStatusMessage,
                                style: TextStyle(
                                    fontSize: 15,
                                    color: Theme.of(context).primaryColor)),
                          ],
                        ),
                      )
                    else if (_searchStatusMessage.isNotEmpty &&
                        !isTripActive &&
                        !_isSearchingForRider)
                      Padding(
                        padding: const EdgeInsets.symmetric(vertical: 8.0),
                        child: Text(_searchStatusMessage,
                            style: TextStyle(
                                fontSize: 15,
                                color: _riderDetails.isNotEmpty
                                    ? Colors.green[700]
                                    : Colors.orange[700],
                                fontWeight: FontWeight.bold),
                            textAlign: TextAlign.center),
                      ),
                    if (_riderDetails.isNotEmpty &&
                        !isTripActive &&
                        !_isSearchingForRider)
                      Padding(
                        padding: const EdgeInsets.symmetric(vertical: 6.0),
                        child: Text(_riderDetails,
                            style: Theme.of(context)
                                .textTheme
                                .bodyMedium
                                ?.copyWith(fontStyle: FontStyle.italic),
                            textAlign: TextAlign.center),
                      ),
                    SizedBox(
                        height: (_isSearchingForRider ||
                                (_searchStatusMessage.isNotEmpty &&
                                    !isTripActive &&
                                    !_isSearchingForRider))
                            ? 8
                            : 0),
                    if (!isTripActive)
                      ElevatedButton(
                        onPressed:
                            isCurrentlyInteractive ? _submitRequest : null,
                        child: Text(_isSearchingForRider
                            ? 'Searching...'
                            : (_isPabiliSelected
                                ? 'Request Pabili'
                                : 'Find a Ride')),
                      )
                    else
                      ElevatedButton.icon(
                        icon: const Icon(Icons.cancel_outlined),
                        label: const Text('Cancel Current Request'),
                        style: ElevatedButton.styleFrom(
                          backgroundColor: Colors.red[400],
                          foregroundColor: Colors.white,
                        ),
                        onPressed: _cancelCurrentOperation,
                      ),
                  ],
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }

  void _submitRequest() async {
    final user = FirebaseAuth.instance.currentUser;
    if (user == null) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
            content: Text('You must be logged in to request a ride.')),
      );
      return;
    }
    if (_pickupLatLng == null || _destinationLatLng == null) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Please select pickup and destination.')),
      );
      return;
    }
    if (_isPabiliSelected &&
        (_itemDescriptionController.text.isEmpty ||
            _estimatedCostController.text.isEmpty)) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
            content: Text(
                'Please enter item description and estimated cost for Pabili.')),
      );
      return;
    }

    // --- LIMIT: Check for existing active bookings for this service ---
    final existing = await FirebaseFirestore.instance
        .collection('bookings')
        .where('userId', isEqualTo: user.uid)
        .where('serviceType', isEqualTo: _selectedService.name)
        .where('status', isEqualTo: 'active')
        .get();

    if (existing.docs.length >= 2) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content:
              Text('You can only have 2 active bookings for this service.'),
          backgroundColor: Colors.red,
        ),
      );
      return;
    }
    // --- END LIMIT ---

    setState(() {
      _isSearchingForRider = true;
      _searchStatusMessage = "Looking for available riders...";
    });
    _showWaitingForRiderDialog();

    final bookingData = {
      'userId': user.uid,
      'serviceType': _selectedService.name,
      'pickup': {
        'address': _pickupController.text,
        'lat': _pickupLatLng!.latitude,
        'lng': _pickupLatLng!.longitude,
      },
      'destination': {
        'address': _destinationController.text,
        'lat': _destinationLatLng!.latitude,
        'lng': _destinationLatLng!.longitude,
      },
      'status': 'active',
      'createdAt': FieldValue.serverTimestamp(),
      'fare': _estimatedFareMessage,
      if (_isPabiliSelected)
        'pabiliDetails': {
          'items': _itemDescriptionController.text,
          'estimatedCost': _estimatedCostController.text,
        },
        'customerMobile': user.phoneNumber,
    };

    try {
      await FirebaseFirestore.instance.collection('bookings').add(bookingData);

      setState(() {
        _isSearchingForRider = false;
        _searchStatusMessage =
            "Booking submitted! Waiting for rider assignment.";
      });

      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Request submitted!')),
      );
    } catch (e) {
      setState(() {
        _isSearchingForRider = false;
        _searchStatusMessage = "";
      });
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Failed to submit request: $e')),
      );
    }
  }

  void _cancelCurrentOperation() async {
    final user = FirebaseAuth.instance.currentUser;
    if (user == null) return;
    final bookingSnap = await FirebaseFirestore.instance
        .collection('bookings')
        .where('userId', isEqualTo: user.uid)
        .where('status', isEqualTo: 'active')
        .limit(1)
        .get();

    if (bookingSnap.docs.isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('No active booking found.')),
      );
      return;
    }

    final bookingData = bookingSnap.docs.first.data();
    final bookingId = bookingSnap.docs.first.id;
    final driverAssigned = bookingData['driver'] != null &&
        bookingData['driver'].toString().isNotEmpty;

    if (driverAssigned) {
      final confirm = await showDialog<bool>(
        context: context,
        builder: (context) => AlertDialog(
          title: const Text('Driver Already Assigned'),
          content: const Text(
            'A driver has already accepted your booking. '
            'Cancelling now may inconvenience the driver and could result in a cancellation fee. '
            'Are you sure you want to cancel?',
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.of(context).pop(false),
              child: const Text('No'),
            ),
            TextButton(
              onPressed: () => Navigator.of(context).pop(true),
              child: const Text('Yes, Cancel'),
            ),
          ],
        ),
      );
      if (confirm != true) return;
    }

    final reasons = [
      'Change of plans',
      'Waited too long',
      'Driver not moving',
      'Booked by mistake',
      'Other'
    ];
    String? selectedReason = await showDialog<String>(
      context: context,
      builder: (context) {
        String? tempReason;
        return AlertDialog(
          title: const Text('Cancel Booking'),
          content: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              ...reasons.map((reason) => RadioListTile<String>(
                    title: Text(reason),
                    value: reason,
                    groupValue: tempReason,
                    onChanged: (val) {
                      tempReason = val;
                      setState(() {});
                      Navigator.of(context).pop(val);
                    },
                  )),
            ],
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.of(context).pop(null),
              child: const Text('Close'),
            ),
          ],
        );
      },
    );

    if (selectedReason == null) return;

    try {
      await FirebaseFirestore.instance
          .collection('bookings')
          .doc(bookingId)
          .update({
        'cancellationRequested': true,
        'cancellationReason': selectedReason,
        'cancellationStatus': 'pending',
        'status': 'cancelled',
        'cancelledAt': FieldValue.serverTimestamp(),
      });

      setState(() {
        _isSearchingForRider = false;
        _searchStatusMessage = "";
        _simulatedRiderPosition = null;
        _riderDetails = "";
        _simulationNotificationMessage = "";
        _routePolylinePoints = [];
        _routePolylinePoints = [];
      });
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Booking cancelled.')),
      );
    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Failed to cancel booking: $e')),
      );
    }
  }

  @override
  void dispose() {
    _pickupController.dispose();
    _destinationController.dispose();
    _itemDescriptionController.dispose();
    _estimatedCostController.dispose();
    _riderSimulationTimer?.cancel();
    _bookingListener?.cancel();
    super.dispose();
  }
}
